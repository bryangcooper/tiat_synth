<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Synthviz</title>

<!-- Tone.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<!-- Hydra - try multiple CDNs -->
<script>
  // Try to load Hydra from multiple CDNs
  window.loadHydra = function() {
    // Check if already loaded
    if (typeof Hydra !== 'undefined' || typeof window.Hydra !== 'undefined') {
      console.log('Hydra already loaded');
      return;
    }
    
    // Try jsdelivr first
    const script1 = document.createElement('script');
    script1.src = 'https://cdn.jsdelivr.net/npm/hydra-synth@latest/dist/hydra-synth.js';
    script1.onload = () => {
      console.log('Hydra script loaded from jsdelivr');
      // Check if Hydra is now available (might take a moment)
      setTimeout(() => {
        if (typeof Hydra !== 'undefined') {
          window.Hydra = Hydra;
          console.log('Hydra class available');
        } else {
          console.warn('Hydra script loaded but class not found');
        }
      }, 100);
    };
    script1.onerror = () => {
      console.warn('jsdelivr failed, trying unpkg...');
      // Fallback to unpkg
      const script2 = document.createElement('script');
      script2.src = 'https://unpkg.com/hydra-synth@latest/dist/hydra-synth.js';
      script2.onload = () => {
        console.log('Hydra script loaded from unpkg');
        setTimeout(() => {
          if (typeof Hydra !== 'undefined') {
            window.Hydra = Hydra;
            console.log('Hydra class available');
          }
        }, 100);
      };
      script2.onerror = () => {
        console.error('Failed to load Hydra from all CDNs');
      };
      document.head.appendChild(script2);
    };
    document.head.appendChild(script1);
  };
  
  // Load Hydra when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', window.loadHydra);
  } else {
    window.loadHydra();
  }
</script>

<style>
  /* Basic app look */
  html,body { height:100%; margin:0; background:#000; color:#eee; font-family: Inter, Arial, sans-serif; overflow:hidden; }
  #wrapper { position:relative; width:100vw; height:100vh; }
  .top-bar { position:absolute; top:0; left:0; right:0; height:56px; display:flex; align-items:center; justify-content:space-between; padding:8px 16px; background:rgba(255,255,255,0.03); z-index:50; }
  .title { font-size:14px; color:rgba(255,255,255,0.8); text-align:center; width:100%; position:absolute; left:0; right:0; margin:auto; pointer-events:none; }
  .controls { display:flex; gap:10px; align-items:center; z-index:60; }

  #start-wrapper { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; z-index:100; background:linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.8)); flex-direction:column; }
  #start-button { background:#4caf50; border:none; color:white; padding:12px 18px; border-radius:8px; font-size:16px; cursor:pointer; }
  #meta { margin-top:12px; color:#ccc; max-width:640px; text-align:center; line-height:1.4; }

  /* Right-side big panel */
  #panel { position:absolute; right:16px; top:72px; width:360px; max-height:calc(100vh - 88px); overflow:auto; padding:14px; border-radius:10px; background:rgba(0,0,0,0.6); box-shadow:0 8px 30px rgba(0,0,0,0.6); z-index:70; transition:max-height 0.3s ease; }
  #panel.collapsed-panel { max-height:60px; overflow:hidden; }
  h3 { margin:0 0 10px 0; font-size:13px; color:#ddd; }
  .section { margin-bottom:18px; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.04); }
  .row { display:flex; align-items:center; gap:8px; margin:8px 0; }
  label { font-size:12px; color:#bfbfbf; width:120px; }
  input[type=range] { flex:1; }
  select, input[type=number] { background:#111; border:1px solid rgba(255,255,255,0.06); color:#eee; padding:6px 8px; border-radius:6px; }
  .small { width:78px; }

  /* Bottom-left active notes */
  #active-notes { position:absolute; left:16px; bottom:16px; display:flex; gap:6px; flex-wrap:wrap; z-index:60; }
  .note-bubble { background:rgba(76,175,80,0.12); border:1px solid rgba(76,175,80,0.25); padding:6px 8px; border-radius:6px; font-weight:600; color:#cfeecf; font-size:13px; }

  /* Keyboard helper */
  #keyboard-helper { position:absolute; right:400px; top:72px; background:rgba(0,0,0,0.65); padding:12px; border-radius:8px; z-index:70; width:500px; }
  .hint { font-size:12px; color:#bdbdbd; }
  
  /* Stored notes display */
  #stored-notes { position:absolute; left:16px; top:72px; background:rgba(0,0,0,0.65); padding:12px; border-radius:8px; z-index:70; min-width:200px; max-width:300px; }
  .stored-note { background:rgba(76,175,80,0.15); border:1px solid rgba(76,175,80,0.3); padding:4px 6px; border-radius:4px; font-size:11px; color:#cfeecf; margin:2px; display:inline-block; }
  .stored-notes-empty { color:#888; font-size:11px; font-style:italic; }
  
  /* Piano keyboard styles */
  .piano-keyboard { display:flex; position:relative; height:80px; margin:8px 0; padding:0; }
  .white-key { flex:1; background:linear-gradient(to bottom, #fff 0%, #f5f5f5 100%); border:1px solid #ccc; border-radius:0 0 4px 4px; position:relative; margin:0; min-width:0; box-shadow:inset 0 -2px 4px rgba(0,0,0,0.1); transition:background 0.1s ease; }
  .white-key.pressed { background:linear-gradient(to bottom, #999 0%, #777 100%); border-color:#666; }
  .black-key { position:absolute; width:14px; height:50px; background:linear-gradient(to bottom, #333 0%, #000 100%); border:1px solid #000; border-radius:0 0 3px 3px; z-index:10; box-shadow:0 2px 4px rgba(0,0,0,0.5); margin-left:-7px; transition:background 0.1s ease; }
  .black-key.pressed { background:linear-gradient(to bottom, #555 0%, #333 100%); border-color:#444; }
  .key-label { position:absolute; bottom:8px; left:0; right:0; text-align:center; font-size:11px; font-weight:bold; color:#333; text-shadow:0 1px 1px rgba(255,255,255,0.8); }
  .black-key .key-label { color:#fff; text-shadow:0 1px 2px rgba(0,0,0,0.8); font-size:9px; bottom:6px; }
  .note-label { position:absolute; top:6px; left:0; right:0; text-align:center; font-size:9px; color:#666; font-weight:normal; }
  .black-key .note-label { color:#aaa; font-size:7px; top:4px; }
  .keyboard-section { margin-bottom:14px; }
  .keyboard-title { font-size:11px; color:#ddd; margin-bottom:6px; font-weight:bold; }

  /* EQ Visualizer */
  #eq-visualizer { position:absolute; left:16px; top:72px; width:300px; background:rgba(0,0,0,0.65); padding:12px; border-radius:8px; z-index:70; display:none; }
  #eq-canvas { width:100%; height:120px; background:rgba(0,0,0,0.3); border-radius:4px; display:block; }
  .eq-label { font-size:10px; color:#888; margin-top:4px; display:flex; justify-content:space-between; }

  /* VJ Shader Canvas */
  #vj-canvas { position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:3; pointer-events:none; background:transparent; display:block; opacity:1; }
  #vj-controls { position:absolute; left:16px; bottom:80px; background:rgba(0,0,0,0.75); padding:14px; border-radius:8px; z-index:80; min-width:280px; max-height:70vh; overflow-y:auto; }
  #vj-shader-editor { display:none; margin-top:12px; }
  #vj-shader-code { width:100%; min-height:200px; background:#1a1a1a; color:#0f0; font-family:'Courier New', monospace; font-size:11px; padding:8px; border:1px solid #333; border-radius:4px; resize:vertical; }
  .vj-editor-controls { display:flex; gap:8px; margin-top:8px; }
  .vj-btn { background:#4caf50; border:none; color:white; padding:6px 12px; border-radius:4px; font-size:11px; cursor:pointer; }
  .vj-btn:hover { background:#45a049; }
  .vj-btn-secondary { background:#666; }
  .vj-btn-secondary:hover { background:#777; }
  .shader-error { background:rgba(200,0,0,0.2); border:1px solid #c00; color:#f88; padding:8px; border-radius:4px; margin-top:8px; font-size:10px; font-family:monospace; display:none; }
  .shader-success { background:rgba(0,200,0,0.2); border:1px solid #0c0; color:#8f8; padding:8px; border-radius:4px; margin-top:8px; font-size:10px; display:none; }
  .vj-control-row { display:flex; align-items:center; gap:8px; margin:8px 0; }
  .vj-control-row label { font-size:11px; color:#bfbfbf; width:100px; }
  .vj-toggle { background:#4caf50; border:none; color:white; padding:8px 16px; border-radius:6px; font-size:12px; cursor:pointer; font-weight:bold; width:100%; margin-top:8px; }
  .vj-toggle.active { background:#2e7d32; }
  .vj-toggle:disabled { background:#444; cursor:not-allowed; }
  .chord-display { background:rgba(76,175,80,0.15); border:1px solid rgba(76,175,80,0.3); padding:8px; border-radius:6px; margin:8px 0; font-size:11px; }
  .chord-name { font-weight:bold; color:#4caf50; font-size:13px; }
  .chord-notes { color:#aaa; font-size:10px; margin-top:4px; }

  /* Collapsible Sections */
  .collapsible-header {
    display:flex;
    align-items:center;
    justify-content:space-between;
    cursor:pointer;
    user-select:none;
    padding:4px 0;
    margin-bottom:8px;
  }
  .collapsible-header:hover {
    opacity:0.8;
  }
  .collapse-toggle {
    font-size:18px;
    color:#888;
    transition:transform 0.2s;
    margin-left:8px;
  }
  .collapsed .collapse-toggle {
    transform:rotate(-90deg);
  }
  .collapsible-content {
    overflow:hidden;
    transition:max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease, margin 0.3s ease;
    max-height:10000px;
    opacity:1;
  }
  .collapsible-content.collapsed {
    max-height:0 !important;
    opacity:0;
    padding:0 !important;
    margin:0 !important;
  }
  .section-header {
    display:flex;
    align-items:center;
    gap:8px;
  }

  /* Responsive */
  @media (max-width:900px) {
    #panel { width:320px; right:8px; top:80px; bottom:8px; }
  }
</style>
</head>
<body>
<div id="wrapper">

  <div class="top-bar">
    <div style="display:flex;align-items:center;gap:8px;">
      <button id="back" class="back-button" style="background:#222;color:#fff;border-radius:6px;padding:6px 10px;border:none;cursor:pointer">← Back</button>
    </div>
    <div class="title">Synthviz WIP</div>
    <div class="controls">
      <span class="hint">Input:</span>
      <select id="input-select" style="background:#111;color:#fff;padding:8px;border-radius:6px;">
        <option value="keyboard">Keyboard</option>
        <option value="midi">MIDI</option>
      </select>

      <span class="hint">Output:</span>
      <select id="output-select" style="background:#111;color:#fff;padding:8px;border-radius:6px;">
        <option value="tonejs">Tone.js</option>
      </select>
    </div>
  </div>

  <div id="start-wrapper">
    <button id="start-button">Start</button>
    <div id="meta">
      Click Start to enable audio. <br> Play with QWERTY (Q..I row, Z..M row) or use a MIDI keyboard.  
      <br>This single file exposes oscillator, filter, LFO, effects, and more.
    </div>
  </div>

  <div id="panel">
    <div class="collapsible-header" onclick="toggleCollapse('panel-main')" style="margin-bottom:12px; padding-bottom:8px; border-bottom:2px solid rgba(255,255,255,0.1);">
      <div class="section-header">
        <h3 style="margin:0; font-size:14px; color:#fff;">Synth Controls</h3>
        <span class="collapse-toggle">▼</span>
      </div>
    </div>
    <div id="panel-main-content" class="collapsible-content">
    <!-- Presets -->
    <div class="section" style="border-bottom:2px solid rgba(255,255,255,0.1);">
      <div class="collapsible-header" onclick="toggleCollapse('presets')">
        <div class="section-header">
          <h3 style="margin:0;">Presets</h3>
          <span class="collapse-toggle">▼</span>
        </div>
      </div>
      <div id="presets-content" class="collapsible-content">
      <div class="row">
        <label>Sound Profile</label>
        <select id="preset-select" style="flex:1;">
          <option value="default">Default</option>
          <option value="dark">Dark</option>
          <option value="ethereal">Ethereal</option>
          <option value="bubbly">Bubbly</option>
          <option value="warm">Warm</option>
          <option value="bright">Bright</option>
          <option value="mellow">Mellow</option>
          <option value="crisp">Crisp</option>
          <option value="smooth">Smooth</option>
          <option value="gritty">Gritty</option>
          <option value="airy">Airy</option>
          <option value="punchy">Punchy</option>
          <option value="dreamy">Dreamy</option>
          <option value="metallic">Metallic</option>
          <option value="woody">Woody</option>
          <option value="glassy">Glassy</option>
        </select>
      </div>
      </div>
    </div>

    <!-- OSC -->
    <div class="section">
      <div class="collapsible-header" onclick="toggleCollapse('oscillator')">
        <div class="section-header">
          <h3 style="margin:0;">Oscillator / Pitch</h3>
          <span class="collapse-toggle">▼</span>
        </div>
      </div>
      <div id="oscillator-content" class="collapsible-content">
      <div class="row">
        <label>Waveform</label>
        <select id="osc-wave">
          <option value="sine">sine</option>
          <option value="square">square</option>
          <option value="triangle">triangle</option>
          <option value="sawtooth">sawtooth</option>
        </select>
      </div>

      <div class="row">
        <label>Detune (cents)</label>
        <input id="detune" type="range" min="-1200" max="1200" step="1" value="0">
        <div style="width:52px;text-align:right;color:#bdbdbd" id="detune-val">0</div>
      </div>

      <div class="row">
        <label>Portamento (s)</label>
        <input id="portamento" type="range" min="0" max="1" step="0.01" value="0">
        <div style="width:52px;text-align:right;color:#bdbdbd" id="port-val">0.00</div>
      </div>

      <div class="row">
        <label>Polyphony</label>
        <select id="polyphony">
          <option>4</option><option selected>8</option><option>12</option><option>16</option><option>32</option>
        </select>
        <div style="width:60px;text-align:right;color:#bdbdbd" id="voice-count-label">8</div>
      </div>
      </div>
    </div>

    <!-- Filter -->
    <div class="section">
      <div class="collapsible-header" onclick="toggleCollapse('filter')">
        <div class="section-header">
          <h3 style="margin:0;">Filter</h3>
          <span class="collapse-toggle">▼</span>
        </div>
      </div>
      <div id="filter-content" class="collapsible-content">

      <div class="row">
        <label>Type</label>
        <select id="filter-type">
          <option value="lowpass">lowpass</option>
          <option value="highpass">highpass</option>
          <option value="bandpass">bandpass</option>
          <option value="notch">notch</option>
        </select>
      </div>

      <div class="row">
        <label>Cutoff (Hz)</label>
        <input id="filter-cutoff" type="range" min="50" max="12000" step="1" value="2000">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="cutoff-val">2000</div>
      </div>

      <div class="row">
        <label>Resonance (Q)</label>
        <input id="filter-q" type="range" min="0.1" max="20" step="0.1" value="1">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="q-val">1.0</div>
      </div>

      <div class="row">
        <label>Filter Gain (dB)</label>
        <input id="filter-gain" type="range" min="-24" max="24" step="0.5" value="0">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="f-gain-val">0</div>
      </div>

      <div style="margin-top:8px;font-size:12px;color:#bfbfbf">Filter Envelope</div>

      <div class="row" style="margin-top:6px">
        <label>Env Amount (Hz)</label>
        <input id="filter-env-amount" type="range" min="0" max="6000" step="1" value="800">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="fenv-amt-val">800</div>
      </div>

      <div class="row">
        <label>Env Attack</label>
        <input id="fenv-attack" type="range" min="0.001" max="1.5" step="0.001" value="0.01">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="fenv-a-val">0.010</div>
      </div>

      <div class="row">
        <label>Env Decay</label>
        <input id="fenv-decay" type="range" min="0.001" max="2.5" step="0.001" value="0.12">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="fenv-d-val">0.120</div>
      </div>

      <div class="row">
        <label>Env Sustain</label>
        <input id="fenv-sustain" type="range" min="0" max="1" step="0.01" value="0.0">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="fenv-s-val">0.00</div>
      </div>

      <div class="row">
        <label>Env Release</label>
        <input id="fenv-release" type="range" min="0.01" max="5" step="0.01" value="0.6">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="fenv-r-val">0.60</div>
      </div>
      </div>
    </div>

    <!-- LFO -->
    <div class="section">
      <div class="collapsible-header" onclick="toggleCollapse('lfo')">
        <div class="section-header">
          <h3 style="margin:0;">LFO</h3>
          <span class="collapse-toggle">▼</span>
        </div>
      </div>
      <div id="lfo-content" class="collapsible-content">

      <div class="row">
        <label>Wave</label>
        <select id="lfo-wave">
          <option value="sine">sine</option>
          <option value="triangle">triangle</option>
          <option value="square">square</option>
          <option value="sawtooth">sawtooth</option>
        </select>
      </div>

      <div class="row">
        <label>Rate (Hz)</label>
        <input id="lfo-rate" type="range" min="0.01" max="20" step="0.01" value="5">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="lfo-rate-val">5.00</div>
      </div>

      <div class="row">
        <label>Depth (Hz)</label>
        <input id="lfo-depth" type="range" min="0" max="3000" step="1" value="0">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="lfo-depth-val">0</div>
      </div>

      <div class="row">
        <label>Target</label>
        <select id="lfo-target">
          <option value="filter">filter.frequency</option>
          <option value="pitch">pitch (global detune)</option>
          <option value="pan">panning</option>
        </select>
      </div>
      </div>
    </div>

    <!-- Effects -->
    <div class="section">
      <div class="collapsible-header" onclick="toggleCollapse('effects')">
        <div class="section-header">
          <h3 style="margin:0;">Effects</h3>
          <span class="collapse-toggle">▼</span>
        </div>
      </div>
      <div id="effects-content" class="collapsible-content">

      <div class="row">
        <label>Reverb Wet</label>
        <input id="reverb-wet" type="range" min="0" max="1" step="0.01" value="0.12">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="reverb-val">0.12</div>
      </div>

      <div class="row">
        <label>Delay Time (s)</label>
        <input id="delay-time" type="range" min="0" max="1.5" step="0.001" value="0.25">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="delay-time-val">0.25</div>
      </div>

      <div class="row">
        <label>Delay Feedback</label>
        <input id="delay-fb" type="range" min="0" max="0.95" step="0.01" value="0.24">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="delay-fb-val">0.24</div>
      </div>

      <div class="row">
        <label>Chorus Wet</label>
        <input id="chorus-wet" type="range" min="0" max="1" step="0.01" value="0.15">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="chorus-val">0.15</div>
      </div>

      <div class="row">
        <label>Distortion</label>
        <input id="dist-amt" type="range" min="0" max="1" step="0.01" value="0">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="dist-val">0</div>
      </div>
      </div>
    </div>

    <!-- Global -->
    <div class="section">
      <div class="collapsible-header" onclick="toggleCollapse('global')">
        <div class="section-header">
          <h3 style="margin:0;">Global</h3>
          <span class="collapse-toggle">▼</span>
        </div>
      </div>
      <div id="global-content" class="collapsible-content">

      <div class="row">
        <label>Master Volume (dB)</label>
        <input id="master-volume" type="range" min="-60" max="6" step="0.5" value="-12">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="master-val">-12</div>
      </div>

      <div class="row">
        <label>Pan</label>
        <input id="pan" type="range" min="-1" max="1" step="0.01" value="0">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="pan-val">0.00</div>
      </div>

      <div class="row">
        <label>Transpose (semitones)</label>
        <input id="transpose" type="range" min="-24" max="24" step="1" value="0">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="transpose-val">0</div>
      </div>

      <div class="row">
        <label>Octave</label>
        <input id="octave" type="range" min="-3" max="3" step="1" value="0">
        <div style="width:60px;text-align:right;color:#bdbdbd" id="octave-val">0</div>
        <div style="font-size:11px;color:#888;margin-left:4px">(- / +)</div>
      </div>
      </div>
    </div>
    </div> <!-- panel-main-content -->
  </div> <!-- panel -->

  <div id="eq-visualizer">
    <div class="collapsible-header" onclick="toggleCollapse('eq')">
      <div class="section-header">
        <div class="hint"><strong>Frequency Spectrum</strong></div>
        <span class="collapse-toggle">▼</span>
      </div>
    </div>
    <div id="eq-content" class="collapsible-content">
      <canvas id="eq-canvas" width="276" height="120"></canvas>
      <div class="eq-label">
        <span>20Hz</span>
        <span>200Hz</span>
        <span>2kHz</span>
        <span>20kHz</span>
      </div>
    </div>
  </div>

  <div id="keyboard-helper" style="display:block;">
    <div class="collapsible-header" onclick="toggleCollapse('keyboard')">
      <div class="section-header">
        <div class="hint"><strong>Keyboard mapping</strong></div>
        <span class="collapse-toggle">▼</span>
      </div>
    </div>
    <div id="keyboard-content" class="collapsible-content">
    
    <!-- Upper Octave Keyboard (C4-C5) -->
    <div class="keyboard-section">
      <div class="keyboard-title">Upper octave (C4-C5)</div>
      <div class="piano-keyboard" id="upper-keyboard">
        <!-- C4 -->
        <div class="white-key" data-key="0" data-midi="60">
          <div class="key-label">Q</div>
          <div class="note-label">C4</div>
        </div>
        <!-- D4 -->
        <div class="white-key" data-key="1" data-midi="62">
          <div class="key-label">W</div>
          <div class="note-label">D4</div>
        </div>
        <!-- E4 -->
        <div class="white-key" data-key="2" data-midi="64">
          <div class="key-label">E</div>
          <div class="note-label">E4</div>
        </div>
        <!-- F4 -->
        <div class="white-key" data-key="3" data-midi="65">
          <div class="key-label">R</div>
          <div class="note-label">F4</div>
        </div>
        <!-- G4 -->
        <div class="white-key" data-key="4" data-midi="67">
          <div class="key-label">T</div>
          <div class="note-label">G4</div>
        </div>
        <!-- A4 -->
        <div class="white-key" data-key="5" data-midi="69">
          <div class="key-label">Y</div>
          <div class="note-label">A4</div>
        </div>
        <!-- B4 -->
        <div class="white-key" data-key="6" data-midi="71">
          <div class="key-label">U</div>
          <div class="note-label">B4</div>
        </div>
        <!-- C5 -->
        <div class="white-key" data-key="7" data-midi="72">
          <div class="key-label">I</div>
          <div class="note-label">C5</div>
        </div>
        <!-- Black keys positioned between white keys -->
        <!-- C#4 between C and D -->
        <div class="black-key" data-black="0" data-midi="61">
          <div class="key-label">2</div>
          <div class="note-label">C#4</div>
        </div>
        <!-- D#4 between D and E -->
        <div class="black-key" data-black="1" data-midi="63">
          <div class="key-label">3</div>
          <div class="note-label">D#4</div>
        </div>
        <!-- F#4 between F and G -->
        <div class="black-key" data-black="2" data-midi="66">
          <div class="key-label">5</div>
          <div class="note-label">F#4</div>
        </div>
        <!-- G#4 between G and A -->
        <div class="black-key" data-black="3" data-midi="68">
          <div class="key-label">6</div>
          <div class="note-label">G#4</div>
        </div>
        <!-- A#4 between A and B -->
        <div class="black-key" data-black="4" data-midi="70">
          <div class="key-label">7</div>
          <div class="note-label">A#4</div>
        </div>
      </div>
    </div>

    <!-- Lower Octave Keyboard (C3-C4) -->
    <div class="keyboard-section">
      <div class="keyboard-title">Lower octave (C3-C4)</div>
      <div class="piano-keyboard" id="lower-keyboard">
        <!-- C3 -->
        <div class="white-key" data-key="0" data-midi="48">
          <div class="key-label">Z</div>
          <div class="note-label">C3</div>
        </div>
        <!-- D3 -->
        <div class="white-key" data-key="1" data-midi="50">
          <div class="key-label">X</div>
          <div class="note-label">D3</div>
        </div>
        <!-- E3 -->
        <div class="white-key" data-key="2" data-midi="52">
          <div class="key-label">C</div>
          <div class="note-label">E3</div>
        </div>
        <!-- F3 -->
        <div class="white-key" data-key="3" data-midi="53">
          <div class="key-label">V</div>
          <div class="note-label">F3</div>
        </div>
        <!-- G3 -->
        <div class="white-key" data-key="4" data-midi="55">
          <div class="key-label">B</div>
          <div class="note-label">G3</div>
        </div>
        <!-- A3 -->
        <div class="white-key" data-key="5" data-midi="57">
          <div class="key-label">N</div>
          <div class="note-label">A3</div>
        </div>
        <!-- B3 -->
        <div class="white-key" data-key="6" data-midi="59">
          <div class="key-label">M</div>
          <div class="note-label">B3</div>
        </div>
        <!-- C4 -->
        <div class="white-key" data-key="7" data-midi="60">
          <div class="key-label">,</div>
          <div class="note-label">C4</div>
        </div>
        <!-- Black keys positioned between white keys -->
        <!-- C#3 between C and D -->
        <div class="black-key" data-black="0" data-midi="49">
          <div class="key-label">S</div>
          <div class="note-label">C#3</div>
        </div>
        <!-- D#3 between D and E -->
        <div class="black-key" data-black="1" data-midi="51">
          <div class="key-label">D</div>
          <div class="note-label">D#3</div>
        </div>
        <!-- F#3 between F and G -->
        <div class="black-key" data-black="2" data-midi="54">
          <div class="key-label">G</div>
          <div class="note-label">F#3</div>
        </div>
        <!-- G#3 between G and A -->
        <div class="black-key" data-black="3" data-midi="56">
          <div class="key-label">H</div>
          <div class="note-label">G#3</div>
        </div>
        <!-- A#3 between A and B -->
        <div class="black-key" data-black="4" data-midi="58">
          <div class="key-label">J</div>
          <div class="note-label">A#3</div>
        </div>
      </div>
    </div>

    <div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.1);color:#888;font-size:10px;text-align:center">
      <strong style="color:#aaa">- / +</strong> = change octave (current: <span id="octave-display" style="color:#4caf50;font-weight:bold">0</span>)
    </div>
    </div>
  </div>

  <div id="active-notes"></div>

  <!-- VJ Shader Canvas -->
  <canvas id="vj-canvas"></canvas>

  <!-- VJ Controls -->
  <div id="vj-controls">
    <div class="collapsible-header" onclick="toggleCollapse('vj')">
      <div class="section-header">
        <div class="hint"><strong>VJ Shader System</strong></div>
        <span class="collapse-toggle">▼</span>
      </div>
    </div>
    <div id="vj-content" class="collapsible-content">
    
    <div class="chord-display">
      <div class="chord-name" id="current-chord">No Chord</div>
      <div class="chord-notes" id="chord-notes">Press keys to detect chord</div>
    </div>

    <div class="vj-control-row">
      <label>Shader</label>
      <select id="vj-shader" style="background:#111;color:#fff;padding:6px;border-radius:6px;flex:1;">
        <option value="audio-reactive">Audio Reactive</option>
        <option value="chord-colors">Chord Colors</option>
        <option value="frequency-waves">Frequency Waves</option>
        <option value="chord-shapes">Chord Shapes</option>
        <option value="kaleidoscope">Kaleidoscope</option>
        <option value="particles">Particle Field</option>
        <option value="voronoi">Voronoi Cells</option>
        <option value="fluid">Fluid Dynamics</option>
        <option value="custom">Custom Shader</option>
        <option value="hydra">Hydra WIP</option>
      </select>
    </div>

    <div id="vj-hydra-editor" style="display:none; margin-top:12px;">
      <div style="font-size:11px;color:#aaa;margin-bottom:6px;">Hydra Code Editor</div>
      <textarea id="vj-hydra-code" style="width:100%; min-height:200px; background:#1a1a1a; color:#0ff; font-family:'Courier New', monospace; font-size:11px; padding:8px; border:1px solid #333; border-radius:4px; resize:vertical;">// Hydra live coding example
// Available audio inputs: a0 (bass), a1 (mid), a2 (treble), a3 (avgAmp)
// Chord color: h0, h1, h2 (RGB components)
// Use as values directly (not functions)

osc(20, 0.1, 1.2)
  .rotate(() => a0 * 2)
  .scale(() => 1 + a1 * 0.5)
  .color(() => h0, () => h1, () => h2)
  .out()</textarea>
      <div class="vj-editor-controls">
        <button class="vj-btn" id="vj-run-hydra">Run Hydra Code</button>
        <button class="vj-btn vj-btn-secondary" id="vj-stop-hydra">Stop Hydra</button>
        <button class="vj-btn vj-btn-secondary" id="vj-hydra-examples">Load Example</button>
      </div>
      <div style="font-size:10px;color:#888;margin-top:8px;">
        <strong>Audio Inputs:</strong> a0 (bass), a1 (mid), a2 (treble), a3 (avgAmp) - use as values, not functions<br>
        <strong>Chord Color:</strong> h0, h1, h2 (RGB), h3 (intensity) - use as values<br>
        <strong>Time:</strong> t (time), s (speed) - use as values<br>
        <strong>Note:</strong> Use <code>a0</code> not <code>a0()</code> in your code
      </div>
      <div id="hydra-error" class="shader-error"></div>
      <div id="hydra-success" class="shader-success">Hydra code running!</div>
    </div>

    <div id="vj-shader-editor">
      <div style="font-size:11px;color:#aaa;margin-bottom:6px;">Custom Shader Code (GLSL)</div>
      <textarea id="vj-shader-code" placeholder="// Write your custom shader here&#10;// Available uniforms:&#10;// u_time, u_resolution, u_intensity, u_speed, u_scale&#10;// u_chordColor (vec3), u_bass, u_mid, u_treble, u_avgAmp&#10;// u_chordRoot (int), u_chordType (int)&#10;// v_uv (vec2) - UV coordinates (0-1)"></textarea>
      <div class="vj-editor-controls">
        <button class="vj-btn" id="vj-compile-shader">Compile & Apply</button>
        <button class="vj-btn vj-btn-secondary" id="vj-reset-shader">Reset to Default</button>
        <button class="vj-btn vj-btn-secondary" id="vj-load-example">Load Example</button>
      </div>
      <div id="shader-error" class="shader-error"></div>
      <div id="shader-success" class="shader-success">Shader compiled successfully!</div>
    </div>

    <div class="vj-control-row">
      <label>Intensity</label>
      <input id="vj-intensity" type="range" min="0" max="2" step="0.1" value="1" style="flex:1;">
      <span id="vj-intensity-val" style="width:40px;text-align:right;color:#bdbdbd;font-size:11px;">1.0</span>
    </div>

    <div class="vj-control-row">
      <label>Speed</label>
      <input id="vj-speed" type="range" min="0.1" max="3" step="0.1" value="1" style="flex:1;">
      <span id="vj-speed-val" style="width:40px;text-align:right;color:#bdbdbd;font-size:11px;">1.0</span>
    </div>

    <div class="vj-control-row">
      <label>Color Speed</label>
      <input id="vj-color-speed" type="range" min="0" max="2" step="0.1" value="0.5" style="flex:1;">
      <span id="vj-color-speed-val" style="width:40px;text-align:right;color:#bdbdbd;font-size:11px;">0.5</span>
    </div>

    <div class="vj-control-row">
      <label>Scale</label>
      <input id="vj-scale" type="range" min="0.5" max="3" step="0.1" value="1" style="flex:1;">
      <span id="vj-scale-val" style="width:40px;text-align:right;color:#bdbdbd;font-size:11px;">1.0</span>
    </div>

    <div class="vj-control-row">
      <label>Blend Mode</label>
      <select id="vj-blend" style="background:#111;color:#fff;padding:6px;border-radius:6px;flex:1;">
        <option value="normal">Normal</option>
        <option value="add">Add</option>
        <option value="multiply">Multiply</option>
        <option value="screen">Screen</option>
      </select>
    </div>

    <button id="vj-toggle" class="vj-toggle" disabled>Enable VJ (Start Audio First)</button>
    </div>
  </div>

  <div id="stored-notes">
    <div class="hint"><strong>Stored Notes</strong> <span style="font-size:10px;color:#888">(Press / to record, Space to play)</span></div>
    <div id="stored-notes-list" style="margin-top:8px;min-height:20px;">
      <div class="stored-notes-empty">No notes stored</div>
    </div>
  </div>

</div>

<script>
/* ============================
   Full synth wiring (single file)
   ============================ */

let initialized = false;

// Core Tone nodes
let polySynth = null;
let masterVol, masterPan;
let globalFilter;
let filterEnv; // envelope that modulates filter frequency
let lfo;
let reverb, delay, chorus, distortion;
let effectsChainOut; // final node before master
let analyser; // for EQ visualization

// VJ Shader System
let vjGl, vjProgram, vjCanvas, vjUniforms;
let vjEnabled = false;
let vjShaderType = 'audio-reactive';
let vjIntensity = 1.0;
let vjSpeed = 1.0;
let vjColorSpeed = 0.5;
let vjScale = 1.0;
let vjBlendMode = 'normal';
let vjTime = 0;
let currentChord = null;
let chordNotes = [];
let customShaderCode = '';
let hydra = null;
let hydraCanvas = null;
let hydraRunning = false;

// Config state (keeps in sync with UI)
const state = {
  osc: { type: 'sine', detune: 0 },
  portamento: 0,
  polyphony: 8,
  filter: { type: 'lowpass', cutoff: 2000, q: 1, gain: 0 },
  filterEnv: { amount: 800, attack: 0.01, decay: 0.12, sustain: 0.0, release: 0.6 },
  lfo: { wave: 'sine', rate: 5, depth: 0, target: 'filter' },
  effects: { reverbWet: 0.12, delayTime: 0.25, delayFB: 0.24, chorusWet: 0.15, dist: 0 },
  global: { masterVol: -12, pan: 0, transpose: 0, octave: 0 }
};

// Presets configuration
const presets = {
  'default': {
    osc: { type: 'sine', detune: 0 },
    portamento: 0,
    polyphony: 8,
    filter: { type: 'lowpass', cutoff: 2000, q: 1, gain: 0 },
    filterEnv: { amount: 800, attack: 0.01, decay: 0.12, sustain: 0.0, release: 0.6 },
    lfo: { wave: 'sine', rate: 5, depth: 0, target: 'filter' },
    effects: { reverbWet: 0.12, delayTime: 0.25, delayFB: 0.24, chorusWet: 0.15, dist: 0 },
    global: { masterVol: -12, pan: 0, transpose: 0, octave: 0 }
  },
  'dark': {
    osc: { type: 'sawtooth', detune: 0 },
    portamento: 0.1,
    polyphony: 8,
    filter: { type: 'lowpass', cutoff: 800, q: 4, gain: 0 },
    filterEnv: { amount: 2000, attack: 0.3, decay: 0.6, sustain: 0.5, release: 1.0 },
    lfo: { wave: 'sine', rate: 0.5, depth: 100, target: 'filter' },
    effects: { reverbWet: 0.4, delayTime: 0.4, delayFB: 0.3, chorusWet: 0.2, dist: 0.3 },
    global: { masterVol: -10, pan: 0, transpose: 0, octave: 0 }
  },
  'ethereal': {
    osc: { type: 'sawtooth', detune: 12 },
    portamento: 0.5,
    polyphony: 12,
    filter: { type: 'lowpass', cutoff: 2000, q: 1.5, gain: 0 },
    filterEnv: { amount: 1500, attack: 1.0, decay: 1.2, sustain: 0.8, release: 2.5 },
    lfo: { wave: 'sine', rate: 0.3, depth: 300, target: 'filter' },
    effects: { reverbWet: 0.7, delayTime: 0.6, delayFB: 0.4, chorusWet: 0.6, dist: 0 },
    global: { masterVol: -12, pan: 0, transpose: 0, octave: 0 }
  },
  'bubbly': {
    osc: { type: 'triangle', detune: 8 },
    portamento: 0,
    polyphony: 8,
    filter: { type: 'bandpass', cutoff: 3000, q: 6, gain: 2 },
    filterEnv: { amount: 4000, attack: 0.001, decay: 0.1, sustain: 0.0, release: 0.3 },
    lfo: { wave: 'sine', rate: 8, depth: 500, target: 'filter' },
    effects: { reverbWet: 0.25, delayTime: 0.15, delayFB: 0.2, chorusWet: 0.4, dist: 0 },
    global: { masterVol: -10, pan: 0, transpose: 0, octave: 0 }
  },
  'warm': {
    osc: { type: 'sawtooth', detune: 5 },
    portamento: 0.15,
    polyphony: 8,
    filter: { type: 'lowpass', cutoff: 2500, q: 2, gain: 1 },
    filterEnv: { amount: 3000, attack: 0.2, decay: 0.4, sustain: 0.6, release: 0.8 },
    lfo: { wave: 'sine', rate: 2, depth: 200, target: 'filter' },
    effects: { reverbWet: 0.35, delayTime: 0.3, delayFB: 0.25, chorusWet: 0.3, dist: 0 },
    global: { masterVol: -10, pan: 0, transpose: 0, octave: 0 }
  },
  'bright': {
    osc: { type: 'sawtooth', detune: 0 },
    portamento: 0,
    polyphony: 8,
    filter: { type: 'lowpass', cutoff: 6000, q: 3, gain: 2 },
    filterEnv: { amount: 4000, attack: 0.001, decay: 0.3, sustain: 0.4, release: 0.5 },
    lfo: { wave: 'sine', rate: 5, depth: 300, target: 'filter' },
    effects: { reverbWet: 0.2, delayTime: 0.2, delayFB: 0.2, chorusWet: 0.3, dist: 0.1 },
    global: { masterVol: -10, pan: 0, transpose: 0, octave: 0 }
  },
  'mellow': {
    osc: { type: 'triangle', detune: 3 },
    portamento: 0.2,
    polyphony: 8,
    filter: { type: 'lowpass', cutoff: 1800, q: 1.5, gain: 0 },
    filterEnv: { amount: 2000, attack: 0.4, decay: 0.6, sustain: 0.7, release: 1.0 },
    lfo: { wave: 'sine', rate: 1, depth: 150, target: 'filter' },
    effects: { reverbWet: 0.4, delayTime: 0.35, delayFB: 0.25, chorusWet: 0.25, dist: 0 },
    global: { masterVol: -12, pan: 0, transpose: 0, octave: 0 }
  },
  'crisp': {
    osc: { type: 'square', detune: 0 },
    portamento: 0,
    polyphony: 8,
    filter: { type: 'lowpass', cutoff: 4000, q: 5, gain: 0 },
    filterEnv: { amount: 5000, attack: 0.001, decay: 0.2, sustain: 0.3, release: 0.4 },
    lfo: { wave: 'square', rate: 8, depth: 400, target: 'filter' },
    effects: { reverbWet: 0.15, delayTime: 0.18, delayFB: 0.2, chorusWet: 0.2, dist: 0.2 },
    global: { masterVol: -10, pan: 0, transpose: 0, octave: 0 }
  },
  'smooth': {
    osc: { type: 'sine', detune: 0 },
    portamento: 0.3,
    polyphony: 8,
    filter: { type: 'lowpass', cutoff: 3000, q: 2, gain: 0 },
    filterEnv: { amount: 2500, attack: 0.5, decay: 0.7, sustain: 0.8, release: 1.2 },
    lfo: { wave: 'sine', rate: 0.5, depth: 200, target: 'filter' },
    effects: { reverbWet: 0.5, delayTime: 0.4, delayFB: 0.3, chorusWet: 0.4, dist: 0 },
    global: { masterVol: -12, pan: 0, transpose: 0, octave: 0 }
  },
  'gritty': {
    osc: { type: 'sawtooth', detune: 0 },
    portamento: 0,
    polyphony: 6,
    filter: { type: 'lowpass', cutoff: 3000, q: 4, gain: 0 },
    filterEnv: { amount: 4000, attack: 0.005, decay: 0.4, sustain: 0.5, release: 0.6 },
    lfo: { wave: 'square', rate: 7, depth: 350, target: 'filter' },
    effects: { reverbWet: 0.2, delayTime: 0.3, delayFB: 0.35, chorusWet: 0.2, dist: 0.6 },
    global: { masterVol: -8, pan: 0, transpose: 0, octave: 0 }
  },
  'airy': {
    osc: { type: 'sine', detune: 6 },
    portamento: 0.4,
    polyphony: 12,
    filter: { type: 'highpass', cutoff: 500, q: 2, gain: 0 },
    filterEnv: { amount: 2000, attack: 0.6, decay: 0.8, sustain: 0.7, release: 1.5 },
    lfo: { wave: 'sine', rate: 0.4, depth: 250, target: 'filter' },
    effects: { reverbWet: 0.65, delayTime: 0.5, delayFB: 0.3, chorusWet: 0.5, dist: 0 },
    global: { masterVol: -12, pan: 0, transpose: 0, octave: 0 }
  },
  'punchy': {
    osc: { type: 'square', detune: 0 },
    portamento: 0,
    polyphony: 4,
    filter: { type: 'lowpass', cutoff: 3500, q: 6, gain: 0 },
    filterEnv: { amount: 5000, attack: 0.001, decay: 0.2, sustain: 0.2, release: 0.3 },
    lfo: { wave: 'square', rate: 12, depth: 600, target: 'filter' },
    effects: { reverbWet: 0.1, delayTime: 0.12, delayFB: 0.15, chorusWet: 0, dist: 0.4 },
    global: { masterVol: -8, pan: 0, transpose: 0, octave: 0 }
  },
  'dreamy': {
    osc: { type: 'sawtooth', detune: 10 },
    portamento: 0.5,
    polyphony: 12,
    filter: { type: 'lowpass', cutoff: 2200, q: 1.8, gain: 0 },
    filterEnv: { amount: 1800, attack: 0.8, decay: 1.0, sustain: 0.75, release: 2.0 },
    lfo: { wave: 'sine', rate: 0.6, depth: 350, target: 'filter' },
    effects: { reverbWet: 0.6, delayTime: 0.55, delayFB: 0.4, chorusWet: 0.55, dist: 0 },
    global: { masterVol: -12, pan: 0, transpose: 0, octave: 0 }
  },
  'metallic': {
    osc: { type: 'square', detune: 0 },
    portamento: 0,
    polyphony: 8,
    filter: { type: 'bandpass', cutoff: 4000, q: 8, gain: 2 },
    filterEnv: { amount: 3000, attack: 0.001, decay: 0.1, sustain: 0.1, release: 0.5 },
    lfo: { wave: 'square', rate: 10, depth: 500, target: 'filter' },
    effects: { reverbWet: 0.3, delayTime: 0.2, delayFB: 0.25, chorusWet: 0.3, dist: 0.2 },
    global: { masterVol: -10, pan: 0, transpose: 0, octave: 0 }
  },
  'woody': {
    osc: { type: 'sawtooth', detune: 4 },
    portamento: 0.1,
    polyphony: 8,
    filter: { type: 'lowpass', cutoff: 2000, q: 2.5, gain: 0 },
    filterEnv: { amount: 3000, attack: 0.05, decay: 0.5, sustain: 0.4, release: 1.0 },
    lfo: { wave: 'sine', rate: 1.5, depth: 180, target: 'filter' },
    effects: { reverbWet: 0.3, delayTime: 0.3, delayFB: 0.2, chorusWet: 0.2, dist: 0 },
    global: { masterVol: -10, pan: 0, transpose: 0, octave: 0 }
  },
  'glassy': {
    osc: { type: 'sine', detune: 0 },
    portamento: 0,
    polyphony: 8,
    filter: { type: 'bandpass', cutoff: 5000, q: 10, gain: 0 },
    filterEnv: { amount: 3000, attack: 0.001, decay: 0.05, sustain: 0.0, release: 2.5 },
    lfo: { wave: 'sine', rate: 0.3, depth: 0, target: 'filter' },
    effects: { reverbWet: 0.55, delayTime: 0.15, delayFB: 0.1, chorusWet: 0.12, dist: 0 },
    global: { masterVol: -10, pan: 0, transpose: 0, octave: 0 }
  }
};

// Active notes display
const activeNotes = new Map();
// Track original MIDI notes (before transpose/octave) for proper cleanup
const activeMidiNotes = new Set();
// Stored notes for playback
let storedNotes = [];
// Track notes currently playing from stored notes (for spacebar sustain)
let storedNotesPlaying = new Set();

// keyboard mapping
const keyboardLayout = {
  'z': 48, 'x': 50, 'c': 52, 'v': 53, 'b': 55, 'n': 57, 'm': 59, ',': 60,
  's': 49, 'd': 51, 'g': 54, 'h': 56, 'j': 58,
  'q': 60, 'w': 62, 'e': 64, 'r': 65, 't': 67, 'y': 69, 'u': 71, 'i': 72,
  '2': 61, '3': 63, '5': 66, '6': 68, '7': 70
};
let keysPressed = new Set();

// ---------- initialization & setup ----------
document.getElementById('start-button').addEventListener('click', async () => {
  if (initialized) return;
  // Set ultra-low latency mode for interactive performance
  Tone.context.latencyHint = 'interactive';
  Tone.context.lookAhead = 0; // Zero lookahead for absolute minimum latency
  // Try to reduce buffer size for lower latency (if supported)
  try {
    const ctx = Tone.context.rawContext;
    if (ctx) {
      // Request smaller buffer size for lower latency
      if (ctx.createScriptProcessor) {
        ctx.destination.channelCountMode = 'explicit';
      }
      // Try to set a smaller buffer size (browser dependent)
      if (ctx.baseLatency !== undefined) {
        // Some browsers allow buffer size control
        console.log('Audio context base latency:', ctx.baseLatency);
      }
    }
  } catch (e) {
    console.log('Buffer optimization not available:', e);
  }
  await Tone.start();
  // Pre-warm the audio context by triggering a silent note
  try {
    const warmup = new Tone.Oscillator(440, 'sine').toDestination();
    warmup.start();
    warmup.stop(0.001);
    warmup.dispose();
  } catch (e) {}
  await initSynthAudio();
  document.getElementById('start-wrapper').style.display = 'none';
  initialized = true;
  
  // Enable VJ button
  const vjToggle = document.getElementById('vj-toggle');
  if (vjToggle) {
    vjToggle.disabled = false;
    vjToggle.textContent = 'Enable VJ';
  }
  wireVJControls();
});

// Build and (re)create the synth and audio graph
async function initSynthAudio() {
  // Master nodes
  masterVol = new Tone.Volume(state.global.masterVol).toDestination();
  masterPan = new Tone.Panner(state.global.pan).connect(masterVol);

  // Effects
  chorus = new Tone.Chorus({ frequency: 1.5, delayTime: 4, depth: 0.4, type: 'sine', spread: 180 }).start();
  const chorusWetGain = new Tone.Gain(state.effects.chorusWet);

  distortion = new Tone.Distortion(state.effects.dist);
  delay = new Tone.FeedbackDelay(state.effects.delayTime, state.effects.delayFB);
  reverb = new Tone.Reverb({ decay: 2.2, preDelay: 0.01 });
  reverb.generate && reverb.generate(); // try generate if available
  reverb.wet.value = state.effects.reverbWet;

  // Global filter
  globalFilter = new Tone.Filter({
    type: state.filter.type,
    frequency: state.filter.cutoff,
    Q: state.filter.q,
    gain: state.filter.gain
  });

  // Filter envelope: Use Tone.ScaledEnvelope (AmplitudeEnvelope) to modulate frequency
  // We'll implement a simple envelope that outputs 0..1, then scale to Hz.
  // Use exponential curves for faster response
  filterEnv = new Tone.AmplitudeEnvelope({
    attack: state.filterEnv.attack,
    decay: state.filterEnv.decay,
    sustain: state.filterEnv.sustain,
    release: state.filterEnv.release,
    attackCurve: 'exponential', // Faster than linear
    releaseCurve: 'exponential' // Faster than linear
  });

  // LFO (not started until we connect it)
  lfo = new Tone.LFO({
    type: state.lfo.wave,
    frequency: state.lfo.rate,
    min: -state.lfo.depth,
    max: state.lfo.depth
  });
  lfo.stop(); // will start when connect

  // Recreate synth voices & polySynth
  recreatePolySynth();

  // Create analyser for EQ visualization
  analyser = new Tone.Analyser('fft', 1024);
  
  // Routing: polySynth -> globalFilter -> chorus -> distortion -> delay -> reverb -> pan -> master
  polySynth.connect(filterEnv);
  polySynth.connect(globalFilter);
  // filterEnv will modulate filter frequency on trigger events (we'll do mapping in trigger handler)

  globalFilter.connect(chorus);
  chorus.connect(distortion);
  distortion.connect(delay);
  delay.connect(reverb);
  reverb.connect(masterPan);
  // Also connect to analyser for visualization (parallel connection)
  masterPan.connect(analyser);
  // start LFO
  setupLFOConnections();
  // apply current master settings
  masterVol.volume.value = state.global.masterVol;
  masterPan.pan.value = state.global.pan;
  
  // Start EQ visualization
  startEQVisualization();
  
  // Initialize VJ shader system
  initVJSystem();
}

// Helper to create PolySynth with current state
function recreatePolySynth() {
  // Disconnect previous synth if exists
  if (polySynth) {
    try {
      polySynth.dispose && polySynth.dispose();
    } catch (e) {}
  }

  // Create PolySynth using Tone.Synth voices for fast, predictable behavior
  // Use absolute minimum attack time for instant response
  polySynth = new Tone.PolySynth(Tone.Synth, {
    maxPolyphony: Number(state.polyphony),
    voice: Tone.Synth,
    options: {
      oscillator: { type: state.osc.type },
      // Use absolute minimum attack (0.00001s) - essentially instant
      envelope: { attack: 0.00001, decay: 0.1, sustain: 0.3, release: 1.0 },
      detune: state.osc.detune
    }
  });

  // Set portamento on synths if supported (Tone.Synth voices do not have portamento; for glide, we can use Tone.PolySynth.set("voice", {portamento}) but poly synth of synth may not glide; we emulate pitch glide via glide logic in trigger if needed)
  // Connectments will be performed by initSynthAudio(); but if polySynth exists in graph we need to reconnect manually
  // To keep it simple, user must call initSynthAudio after changing polyphony — our UI will call recreateAndReconnect
}

// ==== Input handling (keyboard + MIDI) ====
document.getElementById('input-select').addEventListener('change', (e) => {
  const v = e.target.value;
  if (v === 'keyboard') {
    enableKeyboard();
  } else {
    enableMIDI();
  }
});

// Keyboard
function enableKeyboard() {
  document.getElementById('instructionText')?.remove?.();
  document.getElementById('keyboard-helper').style.display = 'block';

  const kd = (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    if (e.ctrlKey || e.metaKey || e.altKey) return;
    const key = e.key.toLowerCase();
    
    // Handle octave changes
    if (key === '-' || key === '_') {
      changeOctave(-1);
      return;
    }
    if (key === '=' || key === '+') {
      changeOctave(1);
      return;
    }
    
    // Handle recording (/) and playback (space)
    if (key === '/') {
      recordCurrentNotes();
      return;
    }
    if (key === ' ') {
      e.preventDefault(); // Prevent page scroll
      startStoredNotesPlayback();
      return;
    }
    
    if (keysPressed.has(key)) return;
    const midi = keyboardLayout[key];
    if (midi !== undefined) {
      keysPressed.add(key);
      triggerNote(midi);
    }
  };
  const ku = (e) => {
    const key = e.key.toLowerCase();
    
    // Handle spacebar release (stop stored notes playback)
    if (key === ' ') {
      e.preventDefault();
      stopStoredNotesPlayback();
      return;
    }
    
    if (keysPressed.has(key)) {
      const midi = keyboardLayout[key];
      if (midi !== undefined) releaseNote(midi);
      keysPressed.delete(key);
    }
  };
  document.addEventListener('keydown', kd);
  document.addEventListener('keyup', ku);

  // store handlers for cleanup if needed (omitted for brevity)
}

// MIDI
async function enableMIDI() {
  document.getElementById('keyboard-helper').style.display = 'none';
  try {
    const access = await navigator.requestMIDIAccess();
    for (const input of access.inputs.values()) {
      input.onmidimessage = handleMidiMessage;
    }
  } catch (err) {
    alert('MIDI not available: ' + err.message);
    document.getElementById('input-select').value = 'keyboard';
    enableKeyboard();
  }
}

function handleMidiMessage(msg) {
  const [status, note, vel] = msg.data;
  const cmd = status & 0xf0;
  if (cmd === 0x90 && vel > 0) {
    triggerNote(note, vel / 127);
  } else if (cmd === 0x80 || (cmd === 0x90 && vel === 0)) {
    releaseNote(note);
  }
}

// Find visual key element for a MIDI note
function findVisualKey(midi) {
  // Search both keyboards for the key with matching MIDI note
  const keyboards = ['upper-keyboard', 'lower-keyboard'];
  for (const keyboardId of keyboards) {
    const keyboard = document.getElementById(keyboardId);
    if (!keyboard) continue;
    const key = keyboard.querySelector(`[data-midi="${midi}"]`);
    if (key) return key;
  }
  return null;
}

// ----- Note triggering (polyphony friendly) -----
function triggerNote(midi, velocity = 1) {
  if (!polySynth) return;
  // Pre-calculate values to minimize computation during trigger
  const octaveOffset = (state.global.octave || 0) * 12;
  const transposed = Number(midi) + Number(state.global.transpose || 0) + octaveOffset;
  const noteName = Tone.Frequency(transposed, 'midi').toNote();
  
  // Use Tone.immediate() for absolute minimum latency (even better than 0)
  const now = Tone.immediate();
  
  // Trigger synth immediately
  polySynth.triggerAttack(noteName, now, velocity);
  
  // Update filter envelope settings (only if changed to avoid unnecessary work)
  if (filterEnv.attack !== state.filterEnv.attack) filterEnv.attack = state.filterEnv.attack;
  if (filterEnv.decay !== state.filterEnv.decay) filterEnv.decay = state.filterEnv.decay;
  if (filterEnv.sustain !== state.filterEnv.sustain) filterEnv.sustain = state.filterEnv.sustain;
  if (filterEnv.release !== state.filterEnv.release) filterEnv.release = state.filterEnv.release;
  filterEnv.triggerAttack(now);

  // Track original MIDI note for cleanup
  activeMidiNotes.add(midi);
  
  // Defer visual updates to avoid blocking audio thread
  requestAnimationFrame(() => {
    addActiveNoteVisual(transposed);
    const visualKey = findVisualKey(midi);
    if (visualKey) visualKey.classList.add('pressed');
  });
}

function releaseNote(midi) {
  if (!polySynth) return;
  // Pre-calculate values
  const octaveOffset = (state.global.octave || 0) * 12;
  const transposed = Number(midi) + Number(state.global.transpose || 0) + octaveOffset;
  const noteName = Tone.Frequency(transposed, 'midi').toNote();
  const now = Tone.immediate(); // Use immediate for absolute minimum latency
  polySynth.triggerRelease(noteName, now);
  filterEnv.triggerRelease(now);
  activeMidiNotes.delete(midi);
  
  // Defer visual updates to avoid blocking audio thread
  requestAnimationFrame(() => {
    removeActiveNoteVisual(transposed);
    const visualKey = findVisualKey(midi);
    if (visualKey) visualKey.classList.remove('pressed');
  });
}

// ----- Active notes UI -----
function addActiveNoteVisual(midi) {
  const noteName = Tone.Frequency(midi, 'midi').toNote();
  if (activeNotes.has(midi)) return;
  const el = document.createElement('div');
  el.className = 'note-bubble';
  el.textContent = noteName;
  document.getElementById('active-notes').appendChild(el);
  activeNotes.set(midi, el);
}
function removeActiveNoteVisual(midi) {
  const el = activeNotes.get(midi);
  if (!el) return;
  el.style.opacity = '0';
  setTimeout(()=>{ el.remove(); }, 220);
  activeNotes.delete(midi);
}

// ===== LFO connection and update helpers =====
function setupLFOConnections() {
  // ensure lfo has correct min/max depending on depth and target
  const cutoff = Number(state.filter.cutoff);
  const depth = Number(state.lfo.depth);
  const min = -depth;
  const max = depth;
  lfo.min = min;
  lfo.max = max;
  lfo.type = state.lfo.wave;
  lfo.frequency.value = state.lfo.rate;

  // disconnect previously connected targets safely
  try { lfo.disconnect(); } catch (e) {}

  // connect to target
  if (state.lfo.target === 'filter') {
    // We'll route lfo to a function that adjusts the filter frequency around the base cutoff.
    // Create a callback: lfo -> Callback -> set globalFilter.frequency.value to base + lfoValue + filterEnv contribution
    const callback = (val) => {
      // val is in Hz offsets (since lfo.min/max set to +/-depth)
      const base = Number(state.filter.cutoff);
      const envLevel = filterEnv.value; // filterEnv outputs 0..1 (amplitude envelope)
      const envAmt = Number(state.filterEnv.amount) || 0;
      // total = base + lfo + env * envAmt
      const tot = Math.max(20, base + Number(val) + (envLevel * envAmt));
      globalFilter.frequency.value = tot;
    };
    // Connect LFO to callback via Tone.Signal -> use lfo.connect to a Tone.Callback? Use lfo.value for periodic polling by starting lfo and using an interval.
    // Simpler approach: use lfo.connect to a Tone.Gain then to a ScriptProcessor-like callback isn't available. We'll use an internal listener by reading lfo.value on animation frame.
    // Start LFO
    lfo.start();
    // Keep a RAF loop to update filter
    if (!window.__lfoRAF) {
      window.__lfoRAF = true;
      const tick = () => {
        if (!lfo || !globalFilter) { requestAnimationFrame(tick); return; }
        const val = lfo.value; // value between min/max
        callback(val);
        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);
    }
  } else if (state.lfo.target === 'pitch') {
    // connect lfo to master detune: apply as cents applied to polySynth.detune if available
    // We'll implement by reading lfo.value (Hz) and converting to cents ~ 1200*log2((f+base)/base), but simpler: map depth to cents directly by setting lfo.min/max to -depth..depth in cents and then applying to detune
    lfo.min = -state.lfo.depth; lfo.max = state.lfo.depth;
    lfo.start();
    if (!window.__lfoPitchRAF) {
      window.__lfoPitchRAF = true;
      const tick2 = () => {
        if (!lfo || !polySynth) { requestAnimationFrame(tick2); return; }
        const cents = lfo.value;
        // apply detune to all voices by setting state.osc.detune + cents
        polySynth.set({ detune: state.osc.detune + cents });
        requestAnimationFrame(tick2);
      };
      requestAnimationFrame(tick2);
    }
  } else if (state.lfo.target === 'pan') {
    lfo.start();
    if (!window.__lfoPanRAF) {
      window.__lfoPanRAF = true;
      const tick3 = () => {
        if (!lfo || !masterPan) { requestAnimationFrame(tick3); return; }
        // map lfo.value (min..max) to -1..1 pan
        const d = state.lfo.depth || 1;
        const panVal = (lfo.value / (d||1));
        masterPan.pan.value = Math.max(-1, Math.min(1, panVal));
        requestAnimationFrame(tick3);
      };
      requestAnimationFrame(tick3);
    }
  } else {
    lfo.stop();
  }
}

// ====== UI wiring: read elements, apply to state and nodes =======
function $(id) { return document.getElementById(id); }

// Record currently playing notes
function recordCurrentNotes() {
  // Get all currently active MIDI notes (before transpose/octave)
  storedNotes = Array.from(activeMidiNotes);
  updateStoredNotesDisplay();
  console.log('Recorded notes:', storedNotes);
}

// Update stored notes display
function updateStoredNotesDisplay() {
  const container = document.getElementById('stored-notes-list');
  if (!container) return;
  
  container.innerHTML = '';
  
  if (storedNotes.length === 0) {
    container.innerHTML = '<div class="stored-notes-empty">No notes stored</div>';
    return;
  }
  
  storedNotes.forEach(midi => {
    const noteName = Tone.Frequency(midi, 'midi').toNote();
    const el = document.createElement('span');
    el.className = 'stored-note';
    el.textContent = noteName;
    container.appendChild(el);
  });
}

// Start playing stored notes (called on spacebar down)
function startStoredNotesPlayback() {
  if (storedNotes.length === 0) {
    console.log('No stored notes to play');
    return;
  }
  
  // If already playing, don't restart
  if (storedNotesPlaying.size > 0) {
    return;
  }
  
  // Release any currently playing notes first (except stored notes)
  if (polySynth && activeMidiNotes.size > 0) {
    activeMidiNotes.forEach(midi => {
      // Only release if it's not a stored note we're about to play
      if (!storedNotes.includes(midi)) {
        const octaveOffset = (state.global.octave || 0) * 12;
        const transposed = Number(midi) + Number(state.global.transpose || 0) + octaveOffset;
        const noteName = Tone.Frequency(transposed, 'midi').toNote();
        polySynth.triggerRelease(noteName, Tone.immediate());
        activeMidiNotes.delete(midi);
      }
    });
  }
  
  // Clear visual notes for non-stored notes
  document.querySelectorAll('.white-key.pressed, .black-key.pressed').forEach(key => {
    const midi = parseInt(key.getAttribute('data-midi'));
    if (midi !== null && !storedNotes.includes(midi)) {
      key.classList.remove('pressed');
    }
  });
  
  // Play all stored notes simultaneously
  storedNotes.forEach(midi => {
    storedNotesPlaying.add(midi);
    triggerNote(midi, 1);
  });
  
  console.log('Started playing stored notes:', storedNotes);
}

// Stop playing stored notes (called on spacebar up)
function stopStoredNotesPlayback() {
  if (storedNotesPlaying.size === 0) {
    return;
  }
  
  // Release all stored notes that are currently playing
  storedNotesPlaying.forEach(midi => {
    const octaveOffset = (state.global.octave || 0) * 12;
    const transposed = Number(midi) + Number(state.global.transpose || 0) + octaveOffset;
    const noteName = Tone.Frequency(transposed, 'midi').toNote();
    const now = Tone.immediate();
    polySynth.triggerRelease(noteName, now);
    filterEnv.triggerRelease(now);
    activeMidiNotes.delete(midi);
    
    // Remove visual feedback
    requestAnimationFrame(() => {
      removeActiveNoteVisual(transposed);
      const visualKey = findVisualKey(midi);
      if (visualKey) visualKey.classList.remove('pressed');
    });
  });
  
  storedNotesPlaying.clear();
  console.log('Stopped playing stored notes');
}

// Change octave (called by keyboard shortcuts)
function changeOctave(delta) {
  const newOctave = Math.max(-3, Math.min(3, (state.global.octave || 0) + delta));
  
  // Release all currently playing notes before changing octave
  if (polySynth && activeMidiNotes.size > 0) {
    const now = 0; // Immediate release
    // Release all notes from the synth
    polySynth.releaseAll(now);
    // Release filter envelope
    if (filterEnv) filterEnv.triggerRelease(now);
    
    // Clear all active notes visually
    activeNotes.forEach((el) => {
      el.style.opacity = '0';
      setTimeout(() => { el.remove(); }, 220);
    });
    activeNotes.clear();
    // Clear all pressed visual keys
    document.querySelectorAll('.white-key.pressed, .black-key.pressed').forEach(key => {
      key.classList.remove('pressed');
    });
    activeMidiNotes.clear();
    keysPressed.clear();
  }
  
  state.global.octave = newOctave;
  $('octave').value = newOctave;
  $('octave-val').textContent = newOctave;
  $('octave-display').textContent = newOctave;
}

// Apply a preset to state and UI
function applyPreset(presetName) {
  const preset = presets[presetName];
  if (!preset) return;

  // Update state
  Object.assign(state, JSON.parse(JSON.stringify(preset)));

  // Update UI controls
  $('osc-wave').value = state.osc.type;
  $('detune').value = state.osc.detune;
  $('detune-val').textContent = state.osc.detune;
  $('portamento').value = state.portamento;
  $('port-val').textContent = state.portamento.toFixed(2);
  $('polyphony').value = state.polyphony;
  $('voice-count-label').textContent = state.polyphony;

  $('filter-type').value = state.filter.type;
  $('filter-cutoff').value = state.filter.cutoff;
  $('cutoff-val').textContent = state.filter.cutoff;
  $('filter-q').value = state.filter.q;
  $('q-val').textContent = Number(state.filter.q).toFixed(1);
  $('filter-gain').value = state.filter.gain;
  $('f-gain-val').textContent = state.filter.gain;

  $('filter-env-amount').value = state.filterEnv.amount;
  $('fenv-amt-val').textContent = state.filterEnv.amount;
  $('fenv-attack').value = state.filterEnv.attack;
  $('fenv-a-val').textContent = Number(state.filterEnv.attack).toFixed(3);
  $('fenv-decay').value = state.filterEnv.decay;
  $('fenv-d-val').textContent = Number(state.filterEnv.decay).toFixed(3);
  $('fenv-sustain').value = state.filterEnv.sustain;
  $('fenv-s-val').textContent = Number(state.filterEnv.sustain).toFixed(2);
  $('fenv-release').value = state.filterEnv.release;
  $('fenv-r-val').textContent = Number(state.filterEnv.release).toFixed(2);

  $('lfo-wave').value = state.lfo.wave;
  $('lfo-rate').value = state.lfo.rate;
  $('lfo-rate-val').textContent = Number(state.lfo.rate).toFixed(2);
  $('lfo-depth').value = state.lfo.depth;
  $('lfo-depth-val').textContent = state.lfo.depth;
  $('lfo-target').value = state.lfo.target;

  $('reverb-wet').value = state.effects.reverbWet;
  $('reverb-val').textContent = Number(state.effects.reverbWet).toFixed(2);
  $('delay-time').value = state.effects.delayTime;
  $('delay-time-val').textContent = Number(state.effects.delayTime).toFixed(3);
  $('delay-fb').value = state.effects.delayFB;
  $('delay-fb-val').textContent = Number(state.effects.delayFB).toFixed(2);
  $('chorus-wet').value = state.effects.chorusWet;
  $('chorus-val').textContent = Number(state.effects.chorusWet).toFixed(2);
  $('dist-amt').value = state.effects.dist;
  $('dist-val').textContent = Number(state.effects.dist).toFixed(2);

  $('master-volume').value = state.global.masterVol;
  $('master-val').textContent = state.global.masterVol;
  $('pan').value = state.global.pan;
  $('pan-val').textContent = Number(state.global.pan).toFixed(2);
  $('transpose').value = state.global.transpose;
  $('transpose-val').textContent = state.global.transpose;
  $('octave').value = state.global.octave || 0;
  $('octave-val').textContent = state.global.octave || 0;
  $('octave-display').textContent = state.global.octave || 0;

  // Apply to audio nodes if initialized
  if (initialized && polySynth) {
    // Update oscillator
    polySynth.set({ oscillator: { type: state.osc.type }, detune: state.osc.detune });
    
    // Update filter
    if (globalFilter) {
      globalFilter.type = state.filter.type;
      globalFilter.frequency.value = state.filter.cutoff;
      globalFilter.Q = state.filter.q;
      globalFilter.gain = state.filter.gain;
    }
    
    // Update filter envelope
    if (filterEnv) {
      filterEnv.attack = state.filterEnv.attack;
      filterEnv.decay = state.filterEnv.decay;
      filterEnv.sustain = state.filterEnv.sustain;
      filterEnv.release = state.filterEnv.release;
    }
    
    // Update LFO
    if (lfo) {
      lfo.type = state.lfo.wave;
      lfo.frequency.value = state.lfo.rate;
      lfo.min = -state.lfo.depth;
      lfo.max = state.lfo.depth;
      setupLFOConnections();
    }
    
    // Update effects
    if (reverb) reverb.wet.value = state.effects.reverbWet;
    if (delay) {
      delay.delayTime.value = state.effects.delayTime;
      delay.feedback.value = state.effects.delayFB;
    }
    if (chorus) {
      chorus.depth = Math.max(0, Math.min(1, state.effects.chorusWet * 2));
    }
    if (distortion) distortion.distortion = state.effects.dist;
    
    // Update global
    if (masterVol) masterVol.volume.value = state.global.masterVol;
    if (masterPan) masterPan.pan.value = state.global.pan;
    
    // Recreate synth if polyphony changed
    const currentPoly = polySynth.maxPolyphony || 8;
    if (currentPoly !== state.polyphony) {
      recreatePolySynth();
      initSynthAudio();
    }
  }
}

// attach many listeners in a compact way
function wireUI() {

  // Preset selector
  $('preset-select').addEventListener('change', (e) => {
    applyPreset(e.target.value);
  });

  // oscillator
  $('osc-wave').addEventListener('change', (e) => {
    state.osc.type = e.target.value;
    if (polySynth) polySynth.set({ oscillator: { type: state.osc.type } });
  });

  $('detune').addEventListener('input', (e) => {
    state.osc.detune = Number(e.target.value);
    $('detune-val').textContent = e.target.value;
    if (polySynth) polySynth.set({ detune: state.osc.detune });
  });

  $('portamento').addEventListener('input', (e) => {
    state.portamento = Number(e.target.value);
    $('port-val').textContent = state.portamento.toFixed(2);
    // portamento effect is not implemented per-voice here — would require Monophonic voices; still tracked for later.
  });

  $('polyphony').addEventListener('change', (e) => {
    state.polyphony = Number(e.target.value);
    $('voice-count-label').textContent = e.target.value;
    // Recreate synth and reconnect graph
    // Save current connections, then re-init audio graph
    recreatePolySynth();
    // reconnect nodes - simplest to reinitialize the whole audio graph
    if (initialized) initSynthAudio();
  });

  // Filter basic
  $('filter-type').addEventListener('change', (e) => {
    state.filter.type = e.target.value;
    if (globalFilter) globalFilter.type = state.filter.type;
  });

  $('filter-cutoff').addEventListener('input', (e) => {
    state.filter.cutoff = Number(e.target.value);
    $('cutoff-val').textContent = e.target.value;
    if (globalFilter) globalFilter.frequency.value = state.filter.cutoff;
  });

  $('filter-q').addEventListener('input', (e) => {
    state.filter.q = Number(e.target.value);
    $('q-val').textContent = Number(e.target.value).toFixed(1);
    if (globalFilter) globalFilter.Q = state.filter.q;
  });

  $('filter-gain').addEventListener('input', (e) => {
    state.filter.gain = Number(e.target.value);
    $('f-gain-val').textContent = e.target.value;
    if (globalFilter) globalFilter.gain = state.filter.gain;
  });

  // Filter envelope
  $('filter-env-amount').addEventListener('input', (e) => {
    state.filterEnv.amount = Number(e.target.value);
    $('fenv-amt-val').textContent = e.target.value;
  });

  $('fenv-attack').addEventListener('input', (e) => {
    state.filterEnv.attack = Number(e.target.value);
    $('fenv-a-val').textContent = Number(e.target.value).toFixed(3);
  });
  $('fenv-decay').addEventListener('input', (e) => {
    state.filterEnv.decay = Number(e.target.value);
    $('fenv-d-val').textContent = Number(e.target.value).toFixed(3);
  });
  $('fenv-sustain').addEventListener('input', (e) => {
    state.filterEnv.sustain = Number(e.target.value);
    $('fenv-s-val').textContent = Number(e.target.value).toFixed(2);
  });
  $('fenv-release').addEventListener('input', (e) => {
    state.filterEnv.release = Number(e.target.value);
    $('fenv-r-val').textContent = Number(e.target.value).toFixed(2);
  });

  // LFO
  $('lfo-wave').addEventListener('change', (e) => {
    state.lfo.wave = e.target.value;
    if (lfo) { lfo.type = state.lfo.wave; }
  });
  $('lfo-rate').addEventListener('input', (e) => {
    state.lfo.rate = Number(e.target.value);
    $('lfo-rate-val').textContent = Number(e.target.value).toFixed(2);
    if (lfo) lfo.frequency.value = state.lfo.rate;
  });
  $('lfo-depth').addEventListener('input', (e) => {
    state.lfo.depth = Number(e.target.value);
    $('lfo-depth-val').textContent = Number(e.target.value);
    if (lfo) {
      lfo.min = -state.lfo.depth;
      lfo.max = state.lfo.depth;
    }
  });
  $('lfo-target').addEventListener('change', (e) => {
    state.lfo.target = e.target.value;
    // re-setup lfo behavior
    setupLFOConnections();
  });

  // Effects
  $('reverb-wet').addEventListener('input', (e) => {
    state.effects.reverbWet = Number(e.target.value);
    $('reverb-val').textContent = Number(e.target.value).toFixed(2);
    if (reverb) reverb.wet.value = state.effects.reverbWet;
  });
  $('delay-time').addEventListener('input', (e) => {
    state.effects.delayTime = Number(e.target.value);
    $('delay-time-val').textContent = Number(e.target.value);
    if (delay) delay.delayTime.value = state.effects.delayTime;
  });
  $('delay-fb').addEventListener('input', (e) => {
    state.effects.delayFB = Number(e.target.value);
    $('delay-fb-val').textContent = Number(e.target.value);
    if (delay) delay.feedback.value = state.effects.delayFB;
  });
  $('chorus-wet').addEventListener('input', (e) => {
    state.effects.chorusWet = Number(e.target.value);
    $('chorus-val').textContent = Number(e.target.value);
    // simple approach: control chorus.wet via a gain - we used a Gain earlier but didn't expose it; instead adjust chorus.depth as proxy
    if (chorus) {
      chorus.depth = Math.max(0, Math.min(1, state.effects.chorusWet * 2));
    }
  });
  $('dist-amt').addEventListener('input', (e) => {
    state.effects.dist = Number(e.target.value);
    $('dist-val').textContent = Number(e.target.value).toFixed(2);
    if (distortion) distortion.distortion = state.effects.dist;
  });

  // Global
  $('master-volume').addEventListener('input', (e) => {
    state.global.masterVol = Number(e.target.value);
    $('master-val').textContent = state.global.masterVol;
    if (masterVol) masterVol.volume.value = state.global.masterVol;
  });
  $('pan').addEventListener('input', (e) => {
    state.global.pan = Number(e.target.value);
    $('pan-val').textContent = Number(e.target.value).toFixed(2);
    if (masterPan) masterPan.pan.value = state.global.pan;
  });
  $('transpose').addEventListener('input', (e) => {
    state.global.transpose = Number(e.target.value);
    $('transpose-val').textContent = Number(e.target.value);
  });
  $('octave').addEventListener('input', (e) => {
    state.global.octave = Number(e.target.value);
    $('octave-val').textContent = Number(e.target.value);
    $('octave-display').textContent = Number(e.target.value);
  });

  // Detune initial display
  $('detune-val').textContent = $('detune').value;
  $('port-val').textContent = $('portamento').value;
  $('voice-count-label').textContent = $('polyphony').value;
}

// Kick off wiring
wireUI();

/* ============================
   Special: update filter frequency based on filterEnv values
   We'll implement a small periodic updater so filter frequency = baseCutoff + filterEnv.value*envAmount + currentLFO
   ============================ */
(function filterUpdaterLoop() {
  let lastCutoff = state.filter.cutoff;
  const tick = () => {
    if (globalFilter && filterEnv) {
      const base = Number(state.filter.cutoff);
      const envAmt = Number(state.filterEnv.amount);
      const envLevel = filterEnv.value || 0; // 0..1
      // lfo contribution: we'll use lfo.value if available (set up by the RAF loop in setupLFOConnections)
      const lfoContribution = lfo ? lfo.value || 0 : 0;
      const targetFreq = Math.max(20, base + envLevel * envAmt + lfoContribution);
      globalFilter.frequency.value = targetFreq;
    }
    requestAnimationFrame(tick);
  };
  requestAnimationFrame(tick);
})();

/* ============================
   EQ Visualization
   ============================ */
function startEQVisualization() {
  const canvas = document.getElementById('eq-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  
  function draw() {
    if (!analyser || !initialized) {
      requestAnimationFrame(draw);
      return;
    }
    
    // Get frequency data
    const values = analyser.getValue();
    
    // Clear canvas
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(0, 0, width, height);
    
    // Draw grid lines
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
      const y = (height / 4) * i;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }
    
    // Draw frequency bars
    const barCount = 64; // Number of bars to display
    const barWidth = width / barCount;
    const maxValue = 255;
    
    // Draw bars with gradient
    for (let i = 0; i < barCount; i++) {
      // Map to logarithmic frequency scale (20Hz - 20kHz)
      const freqRatio = i / barCount;
      const freq = 20 * Math.pow(20000 / 20, freqRatio);
      const dataIndex = Math.floor((freq / 20000) * values.length);
      const safeIndex = Math.min(Math.max(dataIndex, 0), values.length - 1);
      const value = Math.abs(values[safeIndex]);
      
      // Normalize and scale
      const normalizedValue = Math.min(value / maxValue, 1);
      const barHeight = normalizedValue * height * 0.9;
      
      // Color gradient: low (blue) -> mid (green) -> high (red)
      const hue = 240 - (i / barCount) * 180; // 240 (blue) to 60 (yellow-red)
      ctx.fillStyle = `hsl(${hue}, 70%, ${50 + normalizedValue * 30}%)`;
      
      // Draw bar
      ctx.fillRect(i * barWidth, height - barHeight, barWidth - 1, barHeight);
    }
    
    // Draw filter cutoff line if filter is active
    if (globalFilter) {
      const cutoff = globalFilter.frequency.value;
      // Map cutoff frequency to x position (logarithmic)
      const cutoffX = ((Math.log10(cutoff) - Math.log10(20)) / (Math.log10(20000) - Math.log10(20))) * width;
      ctx.strokeStyle = 'rgba(76, 175, 80, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cutoffX, 0);
      ctx.lineTo(cutoffX, height);
      ctx.stroke();
      
      // Draw filter type indicator
      ctx.fillStyle = 'rgba(76, 175, 80, 0.6)';
      ctx.font = '10px Arial';
      ctx.fillText(state.filter.type, cutoffX + 5, 15);
    }
    
    requestAnimationFrame(draw);
  }
  
  draw();
}

/* ============================
   VJ Shader System (TouchDesigner-like)
   ============================ */

// Vertex shader (simple passthrough)
const vjVertexShader = `
  attribute vec2 a_position;
  varying vec2 v_uv;
  
  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
    v_uv = (a_position + 1.0) * 0.5;
    v_uv.y = 1.0 - v_uv.y; // Flip Y
  }
`;

// Fragment shader templates (ISF-like)
const vjShaders = {
  'audio-reactive': `
    precision highp float;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_intensity;
    uniform float u_speed;
    uniform float u_scale;
    uniform vec3 u_chordColor;
    uniform float u_bass;
    uniform float u_mid;
    uniform float u_treble;
    uniform float u_avgAmp;
    varying vec2 v_uv;
    
    void main() {
      vec2 uv = (v_uv - 0.5) * u_scale;
      float dist = length(uv);
      
      // Audio-reactive waves
      float wave1 = sin(dist * 10.0 - u_time * u_speed * 2.0) * u_bass;
      float wave2 = sin(dist * 15.0 - u_time * u_speed * 3.0) * u_mid;
      float wave3 = sin(dist * 20.0 - u_time * u_speed * 4.0) * u_treble;
      
      float pattern = (wave1 + wave2 + wave3) * u_intensity;
      
      // Color from chord + audio
      vec3 color = u_chordColor * (0.5 + pattern * 0.5);
      color += vec3(wave1 * 0.3, wave2 * 0.3, wave3 * 0.3);
      
      // Add pulsing effect
      float pulse = sin(u_time * u_speed) * 0.1 + 0.9;
      color *= pulse * u_avgAmp;
      
      gl_FragColor = vec4(color, 1.0);
    }
  `,
  
  'chord-colors': `
    precision highp float;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_intensity;
    uniform float u_speed;
    uniform float u_scale;
    uniform vec3 u_chordColor;
    uniform float u_bass;
    uniform float u_mid;
    uniform float u_treble;
    uniform float u_avgAmp;
    uniform int u_chordRoot;
    uniform int u_chordType;
    varying vec2 v_uv;
    
    void main() {
      vec2 uv = v_uv * u_scale;
      
      // Create radial gradient based on chord
      vec2 center = vec2(0.5, 0.5);
      float dist = distance(uv, center);
      
      // Chord-based color modulation
      float hueShift = float(u_chordRoot) / 12.0;
      vec3 baseColor = u_chordColor;
      
      // Add frequency-based rings
      float ring1 = step(0.3, dist) * step(dist, 0.3 + u_bass * 0.2);
      float ring2 = step(0.5, dist) * step(dist, 0.5 + u_mid * 0.2);
      float ring3 = step(0.7, dist) * step(dist, 0.7 + u_treble * 0.2);
      
      vec3 color = baseColor;
      color += ring1 * vec3(1.0, 0.5, 0.0) * u_bass;
      color += ring2 * vec3(0.0, 1.0, 0.5) * u_mid;
      color += ring3 * vec3(0.5, 0.0, 1.0) * u_treble;
      
      // Rotating pattern
      float angle = atan(uv.y - 0.5, uv.x - 0.5) + u_time * u_speed;
      float spiral = sin(angle * 3.0 + dist * 10.0) * 0.5 + 0.5;
      color *= (0.7 + spiral * 0.3);
      
      gl_FragColor = vec4(color * u_intensity * u_avgAmp, 1.0);
    }
  `,
  
  'frequency-waves': `
    precision highp float;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_intensity;
    uniform float u_speed;
    uniform float u_scale;
    uniform vec3 u_chordColor;
    uniform float u_bass;
    uniform float u_mid;
    uniform float u_treble;
    uniform float u_avgAmp;
    varying vec2 v_uv;
    
    void main() {
      vec2 uv = v_uv;
      
      // Multiple frequency bands as waves
      float wave1 = sin(uv.x * 10.0 + u_time * u_speed) * u_bass;
      float wave2 = sin(uv.x * 20.0 + u_time * u_speed * 1.5) * u_mid;
      float wave3 = sin(uv.x * 30.0 + u_time * u_speed * 2.0) * u_treble;
      
      float combined = (wave1 + wave2 + wave3) * 0.33;
      
      // Vertical position based on frequency
      float y1 = 0.2 + wave1 * 0.1;
      float y2 = 0.5 + wave2 * 0.1;
      float y3 = 0.8 + wave3 * 0.1;
      
      // Color bands
      vec3 color = vec3(0.0);
      float dist1 = abs(uv.y - y1);
      float dist2 = abs(uv.y - y2);
      float dist3 = abs(uv.y - y3);
      
      color += exp(-dist1 * 50.0) * vec3(1.0, 0.3, 0.0) * u_bass;
      color += exp(-dist2 * 50.0) * vec3(0.0, 1.0, 0.3) * u_mid;
      color += exp(-dist3 * 50.0) * vec3(0.3, 0.0, 1.0) * u_treble;
      
      // Add chord color overlay
      color = mix(color, u_chordColor, 0.3);
      
      gl_FragColor = vec4(color * u_intensity * u_avgAmp, 1.0);
    }
  `,
  
  'chord-shapes': `
    precision highp float;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_intensity;
    uniform float u_speed;
    uniform float u_scale;
    uniform vec3 u_chordColor;
    uniform float u_bass;
    uniform float u_mid;
    uniform float u_treble;
    uniform float u_avgAmp;
    uniform int u_chordRoot;
    uniform int u_chordType;
    varying vec2 v_uv;
    
    void main() {
      vec2 uv = (v_uv - 0.5) * 2.0 * u_scale;
      
      // Number of sides based on chord type
      float sides = float(u_chordType == 0 ? 3 : u_chordType == 1 ? 4 : u_chordType == 2 ? 5 : 6);
      
      // Create polygon shape
      float angle = atan(uv.y, uv.x);
      float radius = length(uv);
      float segment = 6.28318 / sides;
      float d = cos(floor(0.5 + angle / segment) * segment - angle) * radius;
      
      // Shape with audio-reactive edges
      float shape = smoothstep(0.3 + u_bass * 0.2, 0.3, d);
      
      // Rotate based on chord root
      float rotation = float(u_chordRoot) * 0.5236; // 30 degrees per semitone
      vec2 rotated = vec2(
        uv.x * cos(rotation + u_time * u_speed) - uv.y * sin(rotation + u_time * u_speed),
        uv.x * sin(rotation + u_time * u_speed) + uv.y * cos(rotation + u_time * u_speed)
      );
      
      // Add frequency-based layers
      float layer1 = shape * u_bass;
      float layer2 = shape * u_mid * 0.8;
      float layer3 = shape * u_treble * 0.6;
      
      vec3 color = u_chordColor * (layer1 + layer2 + layer3);
      
      // Add pulsing
      float pulse = sin(u_time * u_speed * 2.0) * 0.2 + 0.8;
      color *= pulse;
      
      gl_FragColor = vec4(color * u_intensity * u_avgAmp, 1.0);
    }
  `,
  
  'kaleidoscope': `
    precision highp float;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_intensity;
    uniform float u_speed;
    uniform float u_scale;
    uniform vec3 u_chordColor;
    uniform float u_bass;
    uniform float u_mid;
    uniform float u_treble;
    uniform float u_avgAmp;
    varying vec2 v_uv;
    
    void main() {
      vec2 uv = (v_uv - 0.5) * 2.0;
      float angle = atan(uv.y, uv.x);
      float radius = length(uv);
      
      // Mirror into segments (kaleidoscope effect)
      float segments = 8.0 + u_bass * 4.0;
      angle = mod(angle, 6.28318 / segments) * segments;
      
      vec2 mirrored = vec2(cos(angle), sin(angle)) * radius;
      
      // Create pattern
      float pattern = sin(mirrored.x * 10.0 + u_time * u_speed) * 
                      sin(mirrored.y * 10.0 + u_time * u_speed * 1.3);
      
      // Frequency-based color bands
      vec3 color = u_chordColor;
      color += vec3(pattern * u_bass, pattern * u_mid, pattern * u_treble);
      
      // Radial gradient
      float radial = 1.0 - smoothstep(0.0, 1.5, radius);
      color *= radial;
      
      gl_FragColor = vec4(color * u_intensity * u_avgAmp, 1.0);
    }
  `,
  
  'particles': `
    precision highp float;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_intensity;
    uniform float u_speed;
    uniform float u_scale;
    uniform vec3 u_chordColor;
    uniform float u_bass;
    uniform float u_mid;
    uniform float u_treble;
    uniform float u_avgAmp;
    varying vec2 v_uv;
    
    void main() {
      vec2 uv = v_uv;
      
      // Particle grid
      vec2 grid = floor(uv * 20.0);
      vec2 cell = fract(uv * 20.0) - 0.5;
      
      // Random movement based on audio
      float id = grid.x + grid.y * 20.0;
      float random = fract(sin(id) * 43758.5453);
      
      vec2 offset = vec2(
        sin(u_time * u_speed + random * 6.28) * u_bass,
        cos(u_time * u_speed + random * 6.28) * u_mid
      ) * 0.3;
      
      float dist = length(cell - offset);
      float particle = smoothstep(0.1, 0.0, dist);
      
      // Color based on frequency
      vec3 color = u_chordColor;
      if (random < 0.33) color *= u_bass;
      else if (random < 0.66) color *= u_mid;
      else color *= u_treble;
      
      gl_FragColor = vec4(color * particle * u_intensity * u_avgAmp, 1.0);
    }
  `,
  
  'voronoi': `
    precision highp float;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_intensity;
    uniform float u_speed;
    uniform float u_scale;
    uniform vec3 u_chordColor;
    uniform float u_bass;
    uniform float u_mid;
    uniform float u_treble;
    uniform float u_avgAmp;
    varying vec2 v_uv;
    
    void main() {
      vec2 uv = v_uv * 10.0;
      
      // Voronoi cells
      vec2 i = floor(uv);
      vec2 f = fract(uv);
      
      float minDist = 1.0;
      vec2 closest;
      
      for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
          vec2 neighbor = vec2(float(x), float(y));
          vec2 point = neighbor + sin(i + neighbor + u_time * u_speed) * 0.5;
          float dist = length(f - point);
          
          if (dist < minDist) {
            minDist = dist;
            closest = i + neighbor;
          }
        }
      }
      
      // Color cells based on audio
      float cellId = closest.x + closest.y * 10.0;
      vec3 color = u_chordColor;
      color += vec3(
        sin(cellId + u_time * u_speed) * u_bass,
        sin(cellId + u_time * u_speed + 2.0) * u_mid,
        sin(cellId + u_time * u_speed + 4.0) * u_treble
      ) * 0.3;
      
      // Edge detection
      float edge = smoothstep(0.0, 0.1, minDist);
      color *= edge;
      
      gl_FragColor = vec4(color * u_intensity * u_avgAmp, 1.0);
    }
  `,
  
  'fluid': `
    precision highp float;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform float u_intensity;
    uniform float u_speed;
    uniform float u_scale;
    uniform vec3 u_chordColor;
    uniform float u_bass;
    uniform float u_mid;
    uniform float u_treble;
    uniform float u_avgAmp;
    varying vec2 v_uv;
    
    void main() {
      vec2 uv = v_uv;
      
      // Fluid-like flow
      vec2 flow = vec2(
        sin(uv.y * 5.0 + u_time * u_speed) * u_bass,
        cos(uv.x * 5.0 + u_time * u_speed) * u_mid
      );
      
      vec2 distorted = uv + flow * 0.1;
      
      // Multiple layers
      float layer1 = sin(distorted.x * 10.0 + u_time * u_speed) * u_bass;
      float layer2 = sin(distorted.y * 10.0 + u_time * u_speed * 1.3) * u_mid;
      float layer3 = sin((distorted.x + distorted.y) * 10.0 + u_time * u_speed * 1.7) * u_treble;
      
      float pattern = (layer1 + layer2 + layer3) * 0.33;
      
      // Color mixing
      vec3 color = u_chordColor;
      color += vec3(layer1 * 0.3, layer2 * 0.3, layer3 * 0.3);
      
      // Add turbulence
      float turbulence = sin(uv.x * 20.0 + u_time * u_speed) * 
                         sin(uv.y * 20.0 + u_time * u_speed) * 0.1;
      color += turbulence;
      
      gl_FragColor = vec4(color * u_intensity * u_avgAmp, 1.0);
    }
  `
};

// Chord detection
function detectChord(activeMidiSet) {
  if (!activeMidiSet || activeMidiSet.size < 2) return null;
  
  const notes = Array.from(activeMidiSet).sort((a, b) => a - b);
  
  // Normalize notes to single octave (0-11)
  const normalizedNotes = notes.map(n => n % 12);
  const uniqueNotes = [...new Set(normalizedNotes)].sort((a, b) => a - b);
  
  // Common chord patterns (as sets of intervals from root)
  const chordPatterns = {
    'major': [0, 4, 7],
    'minor': [0, 3, 7],
    'diminished': [0, 3, 6],
    'augmented': [0, 4, 8],
    'sus2': [0, 2, 7],
    'sus4': [0, 5, 7],
    'major7': [0, 4, 7, 11],
    'minor7': [0, 3, 7, 10],
    'dominant7': [0, 4, 7, 10]
  };
  
  // Try each note as a potential root
  let bestMatch = null;
  let bestScore = 0;
  
  for (let rootIdx = 0; rootIdx < uniqueNotes.length; rootIdx++) {
    const root = uniqueNotes[rootIdx];
    const intervalsFromRoot = uniqueNotes.map(n => (n - root + 12) % 12).sort((a, b) => a - b);
    
    // Check against each chord pattern
    for (const [name, pattern] of Object.entries(chordPatterns)) {
      // Check if all pattern intervals are present (allowing for extra notes)
      const patternSet = new Set(pattern);
      const intervalsSet = new Set(intervalsFromRoot);
      
      // Count how many pattern intervals are present
      let matches = 0;
      for (const interval of pattern) {
        if (intervalsSet.has(interval)) matches++;
      }
      
      // For a good match, we need at least 2 intervals for 2-note chords,
      // or pattern.length - 1 for 3+ note chords
      const minRequired = pattern.length === 2 ? 2 : Math.max(2, pattern.length - 1);
      
      if (matches >= minRequired && matches > bestScore) {
        bestScore = matches;
        bestMatch = {
          root: root,
          type: name,
          rootName: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'][root],
          notes: notes
        };
      }
    }
  }
  
  return bestMatch;
}

// Convert chord to color
function chordToColor(chord) {
  if (!chord) return [0.5, 0.5, 0.5];
  
  const root = chord.root;
  const hue = (root / 12.0) * 360.0;
  
  // Saturation based on chord type
  let sat = 0.7;
  if (chord.type.includes('minor')) sat = 0.6;
  if (chord.type.includes('dim')) sat = 0.5;
  if (chord.type.includes('aug')) sat = 0.9;
  
  // Convert HSL to RGB
  const h = hue / 360.0;
  const s = sat;
  const l = 0.5;
  
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs((h * 6) % 2 - 1));
  const m = l - c / 2;
  
  let r, g, b;
  if (h < 1/6) { r = c; g = x; b = 0; }
  else if (h < 2/6) { r = x; g = c; b = 0; }
  else if (h < 3/6) { r = 0; g = c; b = x; }
  else if (h < 4/6) { r = 0; g = x; b = c; }
  else if (h < 5/6) { r = x; g = 0; b = c; }
  else { r = c; g = 0; b = x; }
  
  return [r + m, g + m, b + m];
}

// Initialize WebGL
function initVJSystem() {
  vjCanvas = document.getElementById('vj-canvas');
  if (!vjCanvas) return;
  
  vjGl = vjCanvas.getContext('webgl', { 
    alpha: true, 
    premultipliedAlpha: false,
    antialias: true 
  }) || vjCanvas.getContext('experimental-webgl');
  
  if (!vjGl) {
    console.warn('WebGL not supported');
    return;
  }
  
  // Set clear color
  vjGl.clearColor(0.0, 0.0, 0.0, 1.0);
  
  // Set canvas size
  vjCanvas.width = window.innerWidth;
  vjCanvas.height = window.innerHeight;
  vjCanvas.style.width = window.innerWidth + 'px';
  vjCanvas.style.height = window.innerHeight + 'px';
  vjGl.viewport(0, 0, vjCanvas.width, vjCanvas.height);
  
  // Make sure canvas is visible
  vjCanvas.style.display = 'block';
  vjCanvas.style.visibility = 'visible';
  
  // Create shader program
  compileShader('audio-reactive');
  
  // Initialize Hydra (after a short delay to ensure library is loaded)
  // Try multiple times in case library loads slowly
  let hydraInitAttempts = 0;
  const tryInitHydra = () => {
    if (hydraInitAttempts < 10) {
      hydraInitAttempts++;
      if (!initHydra()) {
        setTimeout(tryInitHydra, 200);
      }
    }
  };
  setTimeout(tryInitHydra, 100);
  
  // Handle resize
  window.addEventListener('resize', () => {
    vjCanvas.width = window.innerWidth;
    vjCanvas.height = window.innerHeight;
    vjGl.viewport(0, 0, vjCanvas.width, vjCanvas.height);
    if (hydra) {
      hydra.setResolution(window.innerWidth, window.innerHeight);
    }
  });
  
  // Start render loop
  vjRenderLoop();
}

// Initialize Hydra
function initHydra() {
  try {
    // Don't reinitialize if already initialized
    if (hydra) {
      console.log('Hydra already initialized');
      return true;
    }
    
    // Check if Hydra is available - try multiple ways
    let HydraClass = null;
    
    // Check global scope
    if (typeof Hydra !== 'undefined') {
      HydraClass = Hydra;
    } else if (typeof window.Hydra !== 'undefined') {
      HydraClass = window.Hydra;
    } else if (typeof window.hydra !== 'undefined' && window.hydra.constructor) {
      // Sometimes it's exposed as a constructor on the instance
      HydraClass = window.hydra.constructor;
    }
    
    if (!HydraClass) {
      console.warn('Hydra library not loaded yet. Attempting to load...');
      // Try to load it manually if CDN failed
      if (!window.hydraLoadAttempted) {
        window.hydraLoadAttempted = true;
        if (typeof window.loadHydra === 'function') {
          window.loadHydra();
        }
        // Also try direct script injection
        const script = document.createElement('script');
        script.src = 'https://unpkg.com/hydra-synth@latest/dist/hydra-synth.js';
        script.onload = () => {
          console.log('Hydra loaded from fallback CDN, retrying init...');
          setTimeout(initHydra, 200);
        };
        script.onerror = () => {
          console.error('Failed to load Hydra from fallback CDN');
        };
        document.head.appendChild(script);
      }
      return false;
    }
    
    // Ensure canvas is available
    if (!vjCanvas) {
      vjCanvas = document.getElementById('vj-canvas');
      if (!vjCanvas) {
        console.warn('VJ canvas not available for Hydra');
        return false;
      }
    }
    
    hydraCanvas = vjCanvas; // Use the same canvas
    
    // Create Hydra instance
    hydra = new HydraClass({
      canvas: hydraCanvas,
      width: window.innerWidth,
      height: window.innerHeight,
      autoLoop: true, // Hydra manages its own loop
      makeGlobal: true, // Make functions globally available
      numSources: 4,
      numOutputs: 4
    });
    
    // Ensure canvas is visible
    if (hydraCanvas) {
      hydraCanvas.style.display = 'block';
      hydraCanvas.style.visibility = 'visible';
      hydraCanvas.style.pointerEvents = 'none'; // Allow clicks to pass through
    }
    
    // Create audio input sources that we can update
    hydra.a0 = { value: 0.2 };
    hydra.a1 = { value: 0.2 };
    hydra.a2 = { value: 0.2 };
    hydra.a3 = { value: 0.5 };
    hydra.h0 = { value: 0.5 };
    hydra.h1 = { value: 0.5 };
    hydra.h2 = { value: 0.5 };
    hydra.h3 = { value: 1.0 };
    hydra.t = { value: 0 };
    hydra.s = { value: 1.0 };
    
    // Store reference globally for easy access
    window.h = hydra;
    
    console.log('Hydra initialized successfully', hydra);
    return true;
  } catch (e) {
    console.error('Failed to initialize Hydra:', e);
    hydra = null;
    return false;
  }
}

// Update Hydra with audio data
function updateHydraAudio(bass, mid, treble, avgAmp, chordColor) {
  if (!hydra || !hydraRunning) return;
  
  try {
    // Ensure values are numbers
    const safeBass = typeof bass === 'number' ? bass : 0.2;
    const safeMid = typeof mid === 'number' ? mid : 0.2;
    const safeTreble = typeof treble === 'number' ? treble : 0.2;
    const safeAvgAmp = typeof avgAmp === 'number' ? avgAmp : 0.5;
    
    // Update audio input values
    if (hydra.a0) hydra.a0.value = safeBass;
    if (hydra.a1) hydra.a1.value = safeMid;
    if (hydra.a2) hydra.a2.value = safeTreble;
    if (hydra.a3) hydra.a3.value = safeAvgAmp;
    
    // Update chord color values (ensure they're numbers)
    if (hydra.h0) hydra.h0.value = typeof chordColor[0] === 'number' ? chordColor[0] : 0.5;
    if (hydra.h1) hydra.h1.value = typeof chordColor[1] === 'number' ? chordColor[1] : 0.5;
    if (hydra.h2) hydra.h2.value = typeof chordColor[2] === 'number' ? chordColor[2] : 0.5;
    if (hydra.h3) hydra.h3.value = typeof vjIntensity === 'number' ? vjIntensity : 1.0;
    
    // Update time and speed
    if (hydra.t) hydra.t.value = typeof vjTime === 'number' ? vjTime : 0;
    if (hydra.s) hydra.s.value = typeof vjSpeed === 'number' ? vjSpeed : 1.0;
  } catch (e) {
    console.error('Error updating Hydra audio:', e);
  }
}

function compileCustomShader(fragmentSource) {
  if (!vjGl) {
    showShaderError('WebGL not initialized');
    return false;
  }
  
  return compileShaderFromSource(fragmentSource);
}

function compileShader(shaderName) {
  if (!vjGl) return false;
  
  const fragmentSource = vjShaders[shaderName];
  if (!fragmentSource) {
    showShaderError('Shader not found: ' + shaderName);
    return false;
  }
  
  return compileShaderFromSource(fragmentSource);
}

function compileShaderFromSource(fragmentSource) {
  if (!vjGl) return false;
  
  // Compile vertex shader
  const vertexShader = vjGl.createShader(vjGl.VERTEX_SHADER);
  vjGl.shaderSource(vertexShader, vjVertexShader);
  vjGl.compileShader(vertexShader);
  if (!vjGl.getShaderParameter(vertexShader, vjGl.COMPILE_STATUS)) {
    const error = vjGl.getShaderInfoLog(vertexShader);
    console.error('Vertex shader error:', error);
    showShaderError('Vertex shader error: ' + error);
    return false;
  }
  
  // Compile fragment shader
  const fragShader = vjGl.createShader(vjGl.FRAGMENT_SHADER);
  vjGl.shaderSource(fragShader, fragmentSource);
  vjGl.compileShader(fragShader);
  if (!vjGl.getShaderParameter(fragShader, vjGl.COMPILE_STATUS)) {
    const error = vjGl.getShaderInfoLog(fragShader);
    console.error('Fragment shader error:', error);
    showShaderError('Fragment shader error: ' + error);
    return false;
  }
  
  // Create program
  vjProgram = vjGl.createProgram();
  vjGl.attachShader(vjProgram, vertexShader);
  vjGl.attachShader(vjProgram, fragShader);
  vjGl.linkProgram(vjProgram);
  
  if (!vjGl.getProgramParameter(vjProgram, vjGl.LINK_STATUS)) {
    const error = vjGl.getProgramInfoLog(vjProgram);
    console.error('Program link error:', error);
    showShaderError('Program link error: ' + error);
    return false;
  }
  
  // Get attribute and uniform locations
  const positionLocation = vjGl.getAttribLocation(vjProgram, 'a_position');
  
  // Create quad
  const buffer = vjGl.createBuffer();
  vjGl.bindBuffer(vjGl.ARRAY_BUFFER, buffer);
  vjGl.bufferData(vjGl.ARRAY_BUFFER, new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
    -1,  1,
     1, -1,
     1,  1
  ]), vjGl.STATIC_DRAW);
  
  // Store uniform locations
  vjUniforms = {
    time: vjGl.getUniformLocation(vjProgram, 'u_time'),
    resolution: vjGl.getUniformLocation(vjProgram, 'u_resolution'),
    intensity: vjGl.getUniformLocation(vjProgram, 'u_intensity'),
    speed: vjGl.getUniformLocation(vjProgram, 'u_speed'),
    scale: vjGl.getUniformLocation(vjProgram, 'u_scale'),
    chordColor: vjGl.getUniformLocation(vjProgram, 'u_chordColor'),
    bass: vjGl.getUniformLocation(vjProgram, 'u_bass'),
    mid: vjGl.getUniformLocation(vjProgram, 'u_mid'),
    treble: vjGl.getUniformLocation(vjProgram, 'u_treble'),
    avgAmp: vjGl.getUniformLocation(vjProgram, 'u_avgAmp'),
    chordRoot: vjGl.getUniformLocation(vjProgram, 'u_chordRoot'),
    chordType: vjGl.getUniformLocation(vjProgram, 'u_chordType')
  };
  
  vjGl.positionLocation = positionLocation;
  vjGl.buffer = buffer;
  
  return true;
}

function showShaderError(message) {
  const errorDiv = document.getElementById('shader-error');
  const successDiv = document.getElementById('shader-success');
  if (errorDiv) {
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
  }
  if (successDiv) {
    successDiv.style.display = 'none';
  }
}

function showShaderSuccess() {
  const errorDiv = document.getElementById('shader-error');
  const successDiv = document.getElementById('shader-success');
  if (errorDiv) {
    errorDiv.style.display = 'none';
  }
  if (successDiv) {
    successDiv.style.display = 'block';
    setTimeout(() => {
      if (successDiv) successDiv.style.display = 'none';
    }, 2000);
  }
}

function hideShaderMessages() {
  const errorDiv = document.getElementById('shader-error');
  const successDiv = document.getElementById('shader-success');
  if (errorDiv) errorDiv.style.display = 'none';
  if (successDiv) successDiv.style.display = 'none';
}

// Hydra functions
function runHydraCode() {
  // Try to initialize Hydra if not already done
  if (!hydra) {
    console.log('Hydra not initialized, attempting to initialize...');
    const initialized = initHydra();
    if (!initialized) {
      // Wait a bit and try again
      setTimeout(() => {
        if (!hydra) {
          const retryInit = initHydra();
          if (!retryInit) {
            showHydraError('Hydra library not loaded. Please wait a moment and try again, or refresh the page.');
            return;
          }
        }
        // Retry running the code after initialization
        runHydraCode();
      }, 500);
      return;
    }
  }
  
  const code = document.getElementById('vj-hydra-code')?.value || '';
  if (!code.trim()) {
    showHydraError('Hydra code is empty');
    return;
  }
  
  try {
    // Stop previous Hydra render
    if (hydraRunning && hydra && hydra.synth) {
      try {
        if (typeof solid !== 'undefined') {
          solid(0, 0, 0).out();
        }
      } catch (e) {}
    }
    
    // Set up audio-reactive functions that Hydra can use
    // These must be functions that return numbers (not getters)
    // Use Number() to ensure we always return a number, not undefined
    window.a0 = function() { 
      const val = hydra?.a0?.value;
      return typeof val === 'number' ? val : 0.2;
    };
    window.a1 = function() { 
      const val = hydra?.a1?.value;
      return typeof val === 'number' ? val : 0.2;
    };
    window.a2 = function() { 
      const val = hydra?.a2?.value;
      return typeof val === 'number' ? val : 0.2;
    };
    window.a3 = function() { 
      const val = hydra?.a3?.value;
      return typeof val === 'number' ? val : 0.5;
    };
    
    // Chord color functions
    window.h0 = function() { 
      const val = hydra?.h0?.value;
      return typeof val === 'number' ? val : 0.5;
    };
    window.h1 = function() { 
      const val = hydra?.h1?.value;
      return typeof val === 'number' ? val : 0.5;
    };
    window.h2 = function() { 
      const val = hydra?.h2?.value;
      return typeof val === 'number' ? val : 0.5;
    };
    window.h3 = function() { 
      const val = hydra?.h3?.value;
      return typeof val === 'number' ? val : 1.0;
    };
    
    // Time and speed functions
    window.t = function() { 
      const val = hydra?.t?.value;
      return typeof val === 'number' ? val : 0;
    };
    window.s = function() { 
      const val = hydra?.s?.value;
      return typeof val === 'number' ? val : 1.0;
    };
    
    // Execute Hydra code directly (Hydra functions are now global)
    // Wrap in try-catch to handle any errors gracefully
    try {
      eval(code);
      console.log('Hydra code executed successfully');
    } catch (e) {
      console.error('Error executing Hydra code:', e);
      throw e;
    }
    
    hydraRunning = true;
    showHydraSuccess();
  } catch (e) {
    showHydraError('Hydra error: ' + e.message);
    console.error('Hydra execution error:', e);
    hydraRunning = false;
  }
}

function stopHydra() {
  if (hydra && hydra.synth) {
    try {
      // Clear the output with a black solid
      if (typeof solid !== 'undefined') {
        solid(0, 0, 0).out();
      }
    } catch (e) {
      console.error('Error stopping Hydra:', e);
    }
  }
  hydraRunning = false;
  const successDiv = document.getElementById('hydra-success');
  if (successDiv) successDiv.style.display = 'none';
}

function loadHydraExample() {
  const examples = [
    `// Audio-reactive circles
osc(20, 0.1, 1.2)
  .rotate(() => a0() * 2)
  .scale(() => 1 + a1() * 0.5)
  .color(() => h0(), () => h1(), () => h2())
  .out()`,
    
    `// Frequency bands visualization
osc(10, 0, 1)
  .modulate(noise(3).luma())
  .color(() => a0(), () => a1(), () => a2())
  .scale(() => 1 + a3() * 0.5)
  .out()`,
    
    `// Kaleidoscope with audio
osc(20, 0.1, 1.2)
  .kaleid(4)
  .rotate(() => a0() * 2)
  .color(() => h0(), () => h1(), () => h2())
  .scale(() => 1 + a3() * 0.3)
  .out()`,
    
    `// Voronoi cells
voronoi(10, 0.1)
  .color(() => h0(), () => h1(), () => h2())
  .scale(() => 1 + a0() * 0.5)
  .rotate(() => a1() * 3.14)
  .out()`,
    
    `// Plasma effect
osc(20, 0.1, 1.2)
  .modulate(noise(3))
  .color(() => h0(), () => h1(), () => h2())
  .scale(() => 1 + a3() * 0.5)
  .rotate(() => a0() * 2)
  .out()`
  ];
  
  const randomExample = examples[Math.floor(Math.random() * examples.length)];
  const editor = document.getElementById('vj-hydra-code');
  if (editor) {
    editor.value = randomExample;
  }
}

function showHydraError(message) {
  const errorDiv = document.getElementById('hydra-error');
  const successDiv = document.getElementById('hydra-success');
  if (errorDiv) {
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
  }
  if (successDiv) {
    successDiv.style.display = 'none';
  }
}

function showHydraSuccess() {
  const errorDiv = document.getElementById('hydra-error');
  const successDiv = document.getElementById('hydra-success');
  if (errorDiv) {
    errorDiv.style.display = 'none';
  }
  if (successDiv) {
    successDiv.style.display = 'block';
    setTimeout(() => {
      if (successDiv) successDiv.style.display = 'none';
    }, 2000);
  }
}

function vjRenderLoop() {
  if (!vjGl || !vjProgram) {
    requestAnimationFrame(vjRenderLoop);
    return;
  }
  
  // Always render when enabled (even without audio for testing)
  if (vjEnabled) {
    // If Hydra is running, let it handle rendering
    if (vjShaderType === 'hydra' && hydraRunning && hydra) {
      // Hydra handles its own rendering, just update audio inputs
      // This will be done after we calculate audio data
    } else if (vjShaderType === 'hydra') {
      // Hydra mode selected but not running - skip WebGL rendering
      requestAnimationFrame(vjRenderLoop);
      return;
    }
    // Use analyser if available, otherwise use default values
    let freqData = null;
    if (analyser && initialized) {
      freqData = analyser.getValue();
    } else {
      // Create dummy data for testing - animated pattern
      freqData = new Float32Array(1024);
      const time = Date.now() * 0.001;
      for (let i = 0; i < 1024; i++) {
        freqData[i] = (Math.sin(i * 0.1 + time) * 50 + 100) * 0.5;
      }
    }
    // Calculate frequency bands
    const bassEnd = Math.floor(freqData.length * 0.1);
    const midEnd = Math.floor(freqData.length * 0.5);
    
    let bass = 0, mid = 0, treble = 0, avgAmp = 0;
    for (let i = 0; i < freqData.length; i++) {
      const amp = Math.abs(freqData[i]);
      avgAmp += amp;
      if (i < bassEnd) bass += amp;
      else if (i < midEnd) mid += amp;
      else treble += amp;
    }
    
    // Avoid division by zero
    bass = bassEnd > 0 ? (bass / bassEnd) / 255.0 : 0.2; // Default values for visibility
    mid = (midEnd - bassEnd) > 0 ? (mid / (midEnd - bassEnd)) / 255.0 : 0.2;
    treble = (freqData.length - midEnd) > 0 ? (treble / (freqData.length - midEnd)) / 255.0 : 0.2;
    avgAmp = freqData.length > 0 ? Math.max((avgAmp / freqData.length) / 255.0, 0.3) : 0.5; // Ensure minimum visibility
    
    // Detect chord
    currentChord = detectChord(activeMidiNotes);
    const chordColor = chordToColor(currentChord);
    
    // Update Hydra with audio data if running
    if (vjShaderType === 'hydra' && hydraRunning) {
      updateHydraAudio(bass, mid, treble, avgAmp, chordColor);
      // Hydra handles its own rendering, so skip WebGL
      requestAnimationFrame(vjRenderLoop);
      return;
    }
    
    // Skip WebGL rendering if Hydra is active
    if (vjShaderType === 'hydra') {
      requestAnimationFrame(vjRenderLoop);
      return;
    }
    
    // Update chord display
    const chordDisplay = document.getElementById('current-chord');
    const chordNotesDisplay = document.getElementById('chord-notes');
    
    if (chordDisplay && chordNotesDisplay) {
      if (currentChord) {
        chordDisplay.textContent = 
          currentChord.rootName + (currentChord.type === 'major' ? '' : ' ' + currentChord.type);
        chordNotesDisplay.textContent = 
          currentChord.notes.map(n => Tone.Frequency(n, 'midi').toNote()).join(' ');
      } else {
        const noteCount = activeMidiNotes ? activeMidiNotes.size : 0;
        if (noteCount >= 2) {
          chordDisplay.textContent = 'No Chord Detected';
          chordNotesDisplay.textContent = 'Notes: ' + Array.from(activeMidiNotes).map(n => Tone.Frequency(n, 'midi').toNote()).join(' ');
        } else {
          chordDisplay.textContent = 'No Chord';
          chordNotesDisplay.textContent = 'Press 2+ keys to detect chord';
        }
      }
    }
    
    // Update time (always increment for animation)
    vjTime += 0.016 * vjSpeed;
    
    // Debug: Log rendering state occasionally
    if (Math.floor(vjTime * 10) % 60 === 0) {
      console.log('VJ Rendering:', { vjEnabled, initialized, hasAnalyser: !!analyser, bass, mid, treble, avgAmp, chord: currentChord?.rootName });
    }
    
    // Render
    vjGl.useProgram(vjProgram);
    
    // Clear canvas
    vjGl.clearColor(0.0, 0.0, 0.0, 1.0);
    vjGl.clear(vjGl.COLOR_BUFFER_BIT);
    
    // Enable blending
    vjGl.enable(vjGl.BLEND);
    
    // Set blend mode
    if (vjBlendMode === 'add') {
      vjGl.blendFunc(vjGl.SRC_ALPHA, vjGl.ONE);
    } else if (vjBlendMode === 'multiply') {
      vjGl.blendFunc(vjGl.DST_COLOR, vjGl.ZERO);
    } else if (vjBlendMode === 'screen') {
      vjGl.blendFunc(vjGl.ONE, vjGl.ONE_MINUS_SRC_COLOR);
    } else {
      vjGl.blendFunc(vjGl.SRC_ALPHA, vjGl.ONE_MINUS_SRC_ALPHA);
    }
    
    // Set uniforms
    vjGl.uniform1f(vjUniforms.time, vjTime);
    vjGl.uniform2f(vjUniforms.resolution, vjCanvas.width, vjCanvas.height);
    vjGl.uniform1f(vjUniforms.intensity, vjIntensity);
    vjGl.uniform1f(vjUniforms.speed, vjSpeed);
    vjGl.uniform1f(vjUniforms.scale, vjScale);
    vjGl.uniform3f(vjUniforms.chordColor, chordColor[0], chordColor[1], chordColor[2]);
    vjGl.uniform1f(vjUniforms.bass, bass);
    vjGl.uniform1f(vjUniforms.mid, mid);
    vjGl.uniform1f(vjUniforms.treble, treble);
    vjGl.uniform1f(vjUniforms.avgAmp, avgAmp);
    
    if (vjUniforms.chordRoot) {
      vjGl.uniform1i(vjUniforms.chordRoot, currentChord ? currentChord.root : 0);
    }
    if (vjUniforms.chordType) {
      const typeMap = { 'major': 0, 'minor': 1, 'diminished': 2, 'augmented': 3, 'sus2': 4, 'sus4': 5 };
      vjGl.uniform1i(vjUniforms.chordType, currentChord ? (typeMap[currentChord.type] || 0) : 0);
    }
    
    // Draw
    if (vjGl.positionLocation !== undefined && vjGl.buffer) {
      vjGl.enableVertexAttribArray(vjGl.positionLocation);
      vjGl.bindBuffer(vjGl.ARRAY_BUFFER, vjGl.buffer);
      vjGl.vertexAttribPointer(vjGl.positionLocation, 2, vjGl.FLOAT, false, 0, 0);
      vjGl.drawArrays(vjGl.TRIANGLES, 0, 6);
    }
  }
  
  requestAnimationFrame(vjRenderLoop);
}

// Wire up VJ controls (only call once to avoid duplicate listeners)
let vjControlsWired = false;
function wireVJControls() {
  if (vjControlsWired) return; // Prevent duplicate event listeners
  vjControlsWired = true;
  
  const $ = (id) => document.getElementById(id);
  
  $('vj-shader')?.addEventListener('change', (e) => {
    vjShaderType = e.target.value;
    const editor = $('vj-shader-editor');
    const hydraEditor = $('vj-hydra-editor');
    
    if (editor) {
      editor.style.display = vjShaderType === 'custom' ? 'block' : 'none';
    }
    if (hydraEditor) {
      hydraEditor.style.display = vjShaderType === 'hydra' ? 'block' : 'none';
    }
    
    if (vjShaderType === 'hydra') {
      // Stop Hydra if switching away
      if (hydraRunning) {
        stopHydra();
      }
    } else if (vjShaderType !== 'custom') {
      compileShader(vjShaderType);
    }
  });
  
  // Custom shader editor
  $('vj-compile-shader')?.addEventListener('click', () => {
    const code = $('vj-shader-code')?.value || '';
    if (!code.trim()) {
      showShaderError('Shader code is empty');
      return;
    }
    customShaderCode = code;
    const success = compileCustomShader(code);
    if (success) {
      showShaderSuccess();
    }
  });
  
  $('vj-reset-shader')?.addEventListener('click', () => {
    if ($('vj-shader-code')) {
      $('vj-shader-code').value = '';
      customShaderCode = '';
    }
    $('vj-shader').value = 'audio-reactive';
    vjShaderType = 'audio-reactive';
    compileShader('audio-reactive');
    if ($('vj-shader-editor')) {
      $('vj-shader-editor').style.display = 'none';
    }
    hideShaderMessages();
  });
  
  // Hydra controls
  $('vj-run-hydra')?.addEventListener('click', () => {
    runHydraCode();
  });
  
  $('vj-stop-hydra')?.addEventListener('click', () => {
    stopHydra();
  });
  
  $('vj-hydra-examples')?.addEventListener('click', () => {
    loadHydraExample();
  });
  
  $('vj-load-example')?.addEventListener('click', () => {
    const example = `precision highp float;
uniform float u_time;
uniform vec2 u_resolution;
uniform float u_intensity;
uniform float u_speed;
uniform float u_scale;
uniform vec3 u_chordColor;
uniform float u_bass;
uniform float u_mid;
uniform float u_treble;
uniform float u_avgAmp;
varying vec2 v_uv;

void main() {
  vec2 uv = (v_uv - 0.5) * 2.0 * u_scale;
  float dist = length(uv);
  
  // Audio-reactive circles
  float wave1 = sin(dist * 10.0 - u_time * u_speed * 2.0) * u_bass;
  float wave2 = sin(dist * 15.0 - u_time * u_speed * 3.0) * u_mid;
  float wave3 = sin(dist * 20.0 - u_time * u_speed * 4.0) * u_treble;
  
  float pattern = (wave1 + wave2 + wave3) * u_intensity;
  
  // Use chord color
  vec3 color = u_chordColor * (0.5 + pattern * 0.5);
  color += vec3(wave1 * 0.3, wave2 * 0.3, wave3 * 0.3);
  
  // Pulsing effect
  float pulse = sin(u_time * u_speed) * 0.1 + 0.9;
  color *= pulse * u_avgAmp;
  
  gl_FragColor = vec4(color, 1.0);
}`;
    if ($('vj-shader-code')) {
      $('vj-shader-code').value = example;
    }
  });
  
  $('vj-intensity')?.addEventListener('input', (e) => {
    vjIntensity = Number(e.target.value);
    $('vj-intensity-val').textContent = vjIntensity.toFixed(1);
  });
  
  $('vj-speed')?.addEventListener('input', (e) => {
    vjSpeed = Number(e.target.value);
    $('vj-speed-val').textContent = vjSpeed.toFixed(1);
  });
  
  $('vj-color-speed')?.addEventListener('input', (e) => {
    vjColorSpeed = Number(e.target.value);
    $('vj-color-speed-val').textContent = vjColorSpeed.toFixed(1);
  });
  
  $('vj-scale')?.addEventListener('input', (e) => {
    vjScale = Number(e.target.value);
    $('vj-scale-val').textContent = vjScale.toFixed(1);
  });
  
  $('vj-blend')?.addEventListener('change', (e) => {
    vjBlendMode = e.target.value;
  });
  
  // Enable VJ button - use once flag to prevent duplicate handlers
  const toggleBtn = $('vj-toggle');
  if (toggleBtn && !toggleBtn.dataset.listenerAttached) {
    toggleBtn.dataset.listenerAttached = 'true';
    toggleBtn.addEventListener('click', () => {
      vjEnabled = !vjEnabled;
      toggleBtn.textContent = vjEnabled ? 'Disable VJ' : 'Enable VJ';
      toggleBtn.classList.toggle('active', vjEnabled);
      
      // Keep controls visible
      if ($('vj-controls')) {
        $('vj-controls').style.display = 'block';
      }
      // Make canvas visible when enabled
      if (vjCanvas) {
        vjCanvas.style.display = vjEnabled ? 'block' : 'none';
        vjCanvas.style.visibility = vjEnabled ? 'visible' : 'hidden';
      }
      console.log('VJ enabled:', vjEnabled, 'Canvas:', vjCanvas);
    });
  }
}

// Wire VJ controls - will be called after audio starts
// Don't call here to avoid duplicate event listeners

// Reconnect everything when page unload or when user changes settings drastically
// Collapsible sections functionality
function toggleCollapse(sectionId) {
  const content = document.getElementById(sectionId + '-content');
  if (!content) {
    console.warn('Content not found for section:', sectionId);
    return;
  }
  
  // Find the header - it's the previous sibling that has the collapsible-header class
  let header = content.previousElementSibling;
  while (header && !header.classList.contains('collapsible-header')) {
    header = header.previousElementSibling;
  }
  
  if (content && header) {
    const isCollapsed = content.classList.contains('collapsed');
    content.classList.toggle('collapsed');
    header.classList.toggle('collapsed');
    
    // If collapsing the main panel content, also collapse the panel itself
    if (sectionId === 'panel-main') {
      const panel = document.getElementById('panel');
      if (panel) {
        if (content.classList.contains('collapsed')) {
          panel.classList.add('collapsed-panel');
        } else {
          panel.classList.remove('collapsed-panel');
        }
      }
    }
    
    // Store state in localStorage
    const newState = content.classList.contains('collapsed');
    localStorage.setItem('collapsed_' + sectionId, newState);
  } else {
    console.warn('Header not found for section:', sectionId);
  }
}

// Restore collapsed state from localStorage
function restoreCollapsedState() {
  const sections = ['panel-main', 'presets', 'oscillator', 'filter', 'lfo', 'effects', 'global', 'eq', 'keyboard', 'vj'];
  sections.forEach(sectionId => {
    const isCollapsed = localStorage.getItem('collapsed_' + sectionId) === 'true';
    const content = document.getElementById(sectionId + '-content');
    if (!content) return;
    
    // Find the header - it's the previous sibling that has the collapsible-header class
    let header = content.previousElementSibling;
    while (header && !header.classList.contains('collapsible-header')) {
      header = header.previousElementSibling;
    }
    
    if (content && header && isCollapsed) {
      content.classList.add('collapsed');
      header.classList.add('collapsed');
      
      // If the main panel is collapsed, also collapse the panel itself
      if (sectionId === 'panel-main') {
        const panel = document.getElementById('panel');
        if (panel) {
          panel.classList.add('collapsed-panel');
        }
      }
    }
  });
}

// Restore state on page load
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', restoreCollapsedState);
} else {
  restoreCollapsedState();
}

window.addEventListener('beforeunload', () => {
  try { Tone.Transport.stop(); } catch (e) {}
});

/* ============================
   UX touches: show start values in UI (initial)
   ============================ */
document.addEventListener('DOMContentLoaded', () => {
  // fill initial labels
  $('cutoff-val').textContent = $('filter-cutoff').value;
  $('q-val').textContent = Number($('filter-q').value).toFixed(1);
  $('fenv-amt-val').textContent = $('filter-env-amount').value;
  $('fenv-a-val').textContent = Number($('fenv-attack').value).toFixed(3);
  $('fenv-d-val').textContent = Number($('fenv-decay').value).toFixed(3);
  $('fenv-s-val').textContent = Number($('fenv-sustain').value).toFixed(2);
  $('fenv-r-val').textContent = Number($('fenv-release').value).toFixed(2);
  $('lfo-rate-val').textContent = Number($('lfo-rate').value).toFixed(2);
  $('lfo-depth-val').textContent = $('lfo-depth').value;
  $('detune-val').textContent = $('detune').value;
  $('master-val').textContent = $('master-volume').value;
  $('pan-val').textContent = $('pan').value;
  $('reverb-val').textContent = $('reverb-wet').value;
  $('delay-time-val').textContent = $('delay-time').value;
  $('delay-fb-val').textContent = $('delay-fb').value;
  $('chorus-val').textContent = $('chorus-wet').value;
  $('dist-val').textContent = $('dist-amt').value;
  $('voice-count-label').textContent = $('polyphony').value;
  $('transpose-val').textContent = $('transpose').value;
  $('octave-val').textContent = $('octave').value;
  $('octave-display').textContent = $('octave').value;

  // default keyboard enabled
  enableKeyboard();
  
  // Position black keys on piano keyboards
  function positionBlackKeys() {
    const keyboards = ['lower-keyboard', 'upper-keyboard'];
    keyboards.forEach(keyboardId => {
      const keyboard = document.getElementById(keyboardId);
      if (!keyboard) return;
      
      const whiteKeys = keyboard.querySelectorAll('.white-key');
      const blackKeys = keyboard.querySelectorAll('.black-key');
      
      // Black key positions: between white keys
      // C# between keys 0-1, D# between 1-2, F# between 3-4, G# between 4-5, A# between 5-6
      const blackKeyPositions = [0, 1, 3, 4, 5]; // indices of white keys before each black key
      
      blackKeys.forEach((blackKey, index) => {
        const whiteKeyIndex = blackKeyPositions[index];
        if (whiteKeyIndex < whiteKeys.length) {
          const whiteKey = whiteKeys[whiteKeyIndex];
          const whiteKeyWidth = whiteKey.offsetWidth;
          // Position black key at the right edge of the white key (between two white keys)
          const leftPos = whiteKey.offsetLeft + whiteKeyWidth - 7; // -7 to center the 14px black key
          blackKey.style.left = leftPos + 'px';
        }
      });
    });
  }
  
  // Position black keys after a short delay to ensure layout is complete
  setTimeout(positionBlackKeys, 100);
  window.addEventListener('resize', positionBlackKeys);
});

/* ============================
   NOTES:
   - This file intentionally uses a global filter + envelope and LFO RAF loops for stable browser behavior.
   - For per-voice filter envelopes you can switch to Tone.MonoSynth as voice type in PolySynth, but that takes more code to reliably manage.
   - Portamento / glide is not implemented per-voice in this simple poly synth; it requires monophonic glide logic or shared pitch ramping.
   - If you'd like a per-voice filter envelope, a fat oscillator stack, or more modular routings (LFO per-voice), tell me and I'll generate a variant.
   ============================ */

</script>
</body>
</html>

